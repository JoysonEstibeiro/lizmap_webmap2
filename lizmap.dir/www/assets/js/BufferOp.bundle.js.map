{"version":3,"file":"BufferOp.bundle.js","mappings":"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","sources":["webpack://lizmap-web-client/./node_modules/fastpriorityqueue/FastPriorityQueue.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferParameters.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/SegmentPointComparator.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/SegmentNode.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/SortedMap.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/TreeMap.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/SegmentNodeList.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/io/WKTParser.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/io/WKTWriter.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/Octant.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/SegmentString.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/NodableSegmentString.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/NodedSegmentString.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/Noder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/ScaledNoder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geom/TopologyException.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/Intersection.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/Distance.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/LineIntersector.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/RobustLineIntersector.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/NodingValidator.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/Boundable.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/ItemBoundable.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/PriorityQueue.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/SpatialIndex.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/AbstractNode.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/Collections.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/EnvelopeDistance.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/BoundablePair.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/ItemVisitor.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/AbstractSTRtree.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/ItemDistance.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/strtree/STRtree.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geom/LineSegment.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainOverlapAction.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChain.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/Quadrant.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainBuilder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/SinglePassNoder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/MCIndexNoder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/snapround/HotPixel.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/index/chain/MonotoneChainSelectAction.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexPointSnapper.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/SegmentIntersector.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/InteriorIntersectionFinderAdder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/snapround/MCIndexSnapRounder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geom/Location.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/Position.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/EmptyStackException.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/Stack.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/RightmostEdgeFinder.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/LinkedList.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferSubgraph.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferInputLineSimplifier.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentString.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/Angle.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetSegmentGenerator.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveBuilder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/TopologyLocation.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/Label.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/GraphComponent.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/Node.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/NodeMap.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/NodeFactory.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEnd.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdge.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/PlanarGraph.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/RayCrossingCounter.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/PointLocation.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeRing.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/overlay/MinimalEdgeRing.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/overlay/MaximalEdgeRing.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/overlay/PolygonBuilder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/SubgraphDepthLocater.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/NotRepresentableException.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/HCoordinate.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geom/Triangle.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/OffsetCurveSetBuilder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js","webpack://lizmap-web-client/./node_modules/jsts/java/util/Iterator.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geom/GeometryCollectionIterator.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeEndStar.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/DirectedEdgeStar.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/overlay/OverlayNodeFactory.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/OrientedCoordinateArray.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeList.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/noding/IntersectionAdder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersection.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/EdgeIntersectionList.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geom/IntersectionMatrix.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/Depth.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/util/IntArrayList.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/geomgraph/Edge.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferBuilder.js","webpack://lizmap-web-client/./node_modules/jsts/org/locationtech/jts/operation/buffer/BufferOp.js"],"sourcesContent":["/**\n * FastPriorityQueue.js : a fast heap-based priority queue  in JavaScript.\n * (c) the authors\n * Licensed under the Apache License, Version 2.0.\n *\n * Speed-optimized heap-based priority queue for modern browsers and JavaScript engines.\n *\n * Usage :\n         Installation (in shell, if you use node):\n         $ npm install fastpriorityqueue\n\n         Running test program (in JavaScript):\n\n         // var FastPriorityQueue = require(\"fastpriorityqueue\");// in node\n         var x = new FastPriorityQueue();\n         x.add(1);\n         x.add(0);\n         x.add(5);\n         x.add(4);\n         x.add(3);\n         x.peek(); // should return 0, leaves x unchanged\n         x.size; // should return 5, leaves x unchanged\n         while(!x.isEmpty()) {\n           console.log(x.poll());\n         } // will print 0 1 3 4 5\n         x.trim(); // (optional) optimizes memory usage\n */\n'use strict';\n\nvar defaultcomparator = function(a, b) {\n  return a < b;\n};\n\n\n// construct a new priority queue\n// the provided comparator function should take a, b and return *true* when a < b\nfunction FastPriorityQueue(comparator) {\n  if (!(this instanceof FastPriorityQueue)) return new FastPriorityQueue(comparator);\n  this.array = [];\n  this.size = 0;\n  this.compare = comparator || defaultcomparator;\n}\n\n// copy the priority queue into another, and return it. Queue items are shallow-copied.\n// Runs in `O(n)` time.\nFastPriorityQueue.prototype.clone = function() {\n  var fpq = new FastPriorityQueue(this.compare);\n  fpq.size = this.size;\n  fpq.array = this.array.slice(0, this.size);\n  return fpq;\n};\n\n// add an element into the queue\n// runs in `O(log n)` time\nFastPriorityQueue.prototype.add = function(myval) {\n  var i = this.size;\n  this.array[this.size] = myval;\n  this.size += 1;\n  var p;\n  var ap;\n  while (i > 0) {\n    p = (i - 1) >> 1;\n    ap = this.array[p];\n    if (!this.compare(myval, ap)) {\n      break;\n    }\n    this.array[i] = ap;\n    i = p;\n  }\n  this.array[i] = myval;\n};\n\n// replace the content of the heap by provided array and \"heapify it\"\nFastPriorityQueue.prototype.heapify = function(arr) {\n  this.array = arr;\n  this.size = arr.length;\n  var i;\n  for (i = this.size >> 1; i >= 0; i--) {\n    this._percolateDown(i);\n  }\n};\n\n// for internal use\nFastPriorityQueue.prototype._percolateUp = function(i, force) {\n  var myval = this.array[i];\n  var p;\n  var ap;\n  while (i > 0) {\n    p = (i - 1) >> 1;\n    ap = this.array[p];\n    // force will skip the compare\n    if (!force && !this.compare(myval, ap)) {\n      break;\n    }\n    this.array[i] = ap;\n    i = p;\n  }\n  this.array[i] = myval;\n};\n\n// for internal use\nFastPriorityQueue.prototype._percolateDown = function(i) {\n  var size = this.size;\n  var hsize = this.size >>> 1;\n  var ai = this.array[i];\n  var l;\n  var r;\n  var bestc;\n  while (i < hsize) {\n    l = (i << 1) + 1;\n    r = l + 1;\n    bestc = this.array[l];\n    if (r < size) {\n      if (this.compare(this.array[r], bestc)) {\n        l = r;\n        bestc = this.array[r];\n      }\n    }\n    if (!this.compare(bestc, ai)) {\n      break;\n    }\n    this.array[i] = bestc;\n    i = l;\n  }\n  this.array[i] = ai;\n};\n\n// internal\n// _removeAt(index) will remove the item at the given index from the queue,\n// retaining balance. returns the removed item, or undefined if nothing is removed.\nFastPriorityQueue.prototype._removeAt = function(index) {\n  if (index > this.size - 1 || index < 0) return undefined;\n\n  // impl1:\n  //this.array.splice(index, 1);\n  //this.heapify(this.array);\n  // impl2:\n  this._percolateUp(index, true);\n  return this.poll();\n};\n\n// remove(myval) will remove an item matching the provided value from the\n// queue, checked for equality by using the queue's comparator.\n// return true if removed, false otherwise.\nFastPriorityQueue.prototype.remove = function(myval) {\n  for (var i = 0; i < this.size; i++) {\n    if (!this.compare(this.array[i], myval) && !this.compare(myval, this.array[i])) {\n      // items match, comparator returns false both ways, remove item\n      this._removeAt(i);\n      return true;\n    }\n  }\n  return false;\n};\n\n// removeOne(callback) will execute the callback function for each item of the queue\n// and will remove the first item for which the callback will return true.\n// return the removed item, or undefined if nothing is removed.\nFastPriorityQueue.prototype.removeOne = function(callback) {\n  if (typeof callback !== \"function\") {\n    return undefined;\n  }\n  for (var i = 0; i < this.size; i++) {\n    if (callback(this.array[i])) {\n      return this._removeAt(i);\n    }\n  }\n};\n\n// remove(callback[, limit]) will execute the callback function for each item of\n// the queue and will remove each item for which the callback returns true, up to\n// a max limit of removed items if specified or no limit if unspecified.\n// return an array containing the removed items.\n// The callback function should be a pure function.\nFastPriorityQueue.prototype.removeMany = function(callback, limit) {\n  // Skip unnecessary processing for edge cases\n  if (typeof callback !== \"function\" || this.size < 1) {\n    return [];\n  }\n  limit = limit ? Math.min(limit, this.size) : this.size;\n\n  // Prepare the results container to hold up to the results limit\n  var resultSize = 0;\n  var result = new Array(limit);\n\n  // Prepare a temporary array to hold items we'll traverse through and need to keep\n  var tmpSize = 0;\n  var tmp = new Array(this.size);\n\n  while (resultSize < limit && !this.isEmpty()) {\n    // Dequeue items into either the results or our temporary array\n    var item = this.poll();\n    if (callback(item)) {\n      result[resultSize++] = item;\n    } else {\n      tmp[tmpSize++] = item;\n    }\n  }\n  // Update the result array with the exact number of results\n  result.length = resultSize;\n\n  // Re-add all the items we can keep\n  var i = 0;\n  while (i < tmpSize) {\n    this.add(tmp[i++]);\n  }\n\n  return result;\n};\n\n// Look at the top of the queue (one of the smallest elements) without removing it\n// executes in constant time\n//\n// Calling peek on an empty priority queue returns\n// the \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\nFastPriorityQueue.prototype.peek = function() {\n  if (this.size == 0) return undefined;\n  return this.array[0];\n};\n\n// remove the element on top of the heap (one of the smallest elements)\n// runs in logarithmic time\n//\n// If the priority queue is empty, the function returns the\n// \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\n// For long-running and large priority queues, or priority queues\n// storing large objects, you may  want to call the trim function\n// at strategic times to recover allocated memory.\nFastPriorityQueue.prototype.poll = function() {\n  if (this.size == 0) return undefined;\n  var ans = this.array[0];\n  if (this.size > 1) {\n    this.array[0] = this.array[--this.size];\n    this._percolateDown(0);\n  } else {\n    this.size -= 1;\n  }\n  return ans;\n};\n\n// This function adds the provided value to the heap, while removing\n// and returning one of the smallest elements (like poll). The size of the queue\n// thus remains unchanged.\nFastPriorityQueue.prototype.replaceTop = function(myval) {\n  if (this.size == 0) return undefined;\n  var ans = this.array[0];\n  this.array[0] = myval;\n  this._percolateDown(0);\n  return ans;\n};\n\n// recover unused memory (for long-running priority queues)\nFastPriorityQueue.prototype.trim = function() {\n  this.array = this.array.slice(0, this.size);\n};\n\n// Check whether the heap is empty\nFastPriorityQueue.prototype.isEmpty = function() {\n  return this.size === 0;\n};\n\n// iterate over the items in order, pass a callback that receives (item, index) as args.\n// TODO once we transpile, uncomment\n// if (Symbol && Symbol.iterator) {\n//   FastPriorityQueue.prototype[Symbol.iterator] = function*() {\n//     if (this.isEmpty()) return;\n//     var fpq = this.clone();\n//     while (!fpq.isEmpty()) {\n//       yield fpq.poll();\n//     }\n//   };\n// }\nFastPriorityQueue.prototype.forEach = function(callback) {\n  if (this.isEmpty() || typeof callback != 'function') return;\n  var i = 0;\n  var fpq = this.clone();\n  while (!fpq.isEmpty()) {\n    callback(fpq.poll(), i++);\n  }\n};\n\n// return the k 'smallest' elements of the queue as an array,\n// runs in O(k log k) time, the elements are not removed\n// from the priority queue.\nFastPriorityQueue.prototype.kSmallest = function(k) {\n  if ((this.size == 0) || (k<=0)) return [];\n  k = Math.min(this.size, k);\n  const newSize = Math.min(this.size, (2 ** (k - 1)) + 1);\n  if (newSize < 2) { return [this.peek()] }\n\n  const fpq = new FastPriorityQueue(this.compare);\n  fpq.size = newSize;\n  fpq.array = this.array.slice(0, newSize);\n\n  const smallest = new Array(k);\n  for (let i = 0; i < k; i++) {\n    smallest[i] = fpq.poll();\n  }\n  return smallest;\n}\n\nmodule.exports = FastPriorityQueue;\n","export default class BufferParameters {\n  constructor() {\n    BufferParameters.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS\n    this._endCapStyle = BufferParameters.CAP_ROUND\n    this._joinStyle = BufferParameters.JOIN_ROUND\n    this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT\n    this._isSingleSided = false\n    this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const quadrantSegments = arguments[0]\n      this.setQuadrantSegments(quadrantSegments)\n    } else if (arguments.length === 2) {\n      const quadrantSegments = arguments[0], endCapStyle = arguments[1]\n      this.setQuadrantSegments(quadrantSegments)\n      this.setEndCapStyle(endCapStyle)\n    } else if (arguments.length === 4) {\n      const quadrantSegments = arguments[0], endCapStyle = arguments[1], joinStyle = arguments[2], mitreLimit = arguments[3]\n      this.setQuadrantSegments(quadrantSegments)\n      this.setEndCapStyle(endCapStyle)\n      this.setJoinStyle(joinStyle)\n      this.setMitreLimit(mitreLimit)\n    }\n  }\n  static bufferDistanceError(quadSegs) {\n    const alpha = Math.PI / 2.0 / quadSegs\n    return 1 - Math.cos(alpha / 2.0)\n  }\n  getEndCapStyle() {\n    return this._endCapStyle\n  }\n  isSingleSided() {\n    return this._isSingleSided\n  }\n  setQuadrantSegments(quadSegs) {\n    this._quadrantSegments = quadSegs\n    if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL\n    if (this._quadrantSegments < 0) {\n      this._joinStyle = BufferParameters.JOIN_MITRE\n      this._mitreLimit = Math.abs(this._quadrantSegments)\n    }\n    if (quadSegs <= 0) \n      this._quadrantSegments = 1\n    \n    if (this._joinStyle !== BufferParameters.JOIN_ROUND) \n      this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS\n    \n  }\n  getJoinStyle() {\n    return this._joinStyle\n  }\n  setJoinStyle(joinStyle) {\n    this._joinStyle = joinStyle\n  }\n  setSimplifyFactor(simplifyFactor) {\n    this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor\n  }\n  getSimplifyFactor() {\n    return this._simplifyFactor\n  }\n  getQuadrantSegments() {\n    return this._quadrantSegments\n  }\n  setEndCapStyle(endCapStyle) {\n    this._endCapStyle = endCapStyle\n  }\n  getMitreLimit() {\n    return this._mitreLimit\n  }\n  setMitreLimit(mitreLimit) {\n    this._mitreLimit = mitreLimit\n  }\n  setSingleSided(isSingleSided) {\n    this._isSingleSided = isSingleSided\n  }\n}\nBufferParameters.CAP_ROUND = 1\nBufferParameters.CAP_FLAT = 2\nBufferParameters.CAP_SQUARE = 3\nBufferParameters.JOIN_ROUND = 1\nBufferParameters.JOIN_MITRE = 2\nBufferParameters.JOIN_BEVEL = 3\nBufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8\nBufferParameters.DEFAULT_MITRE_LIMIT = 5.0\nBufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01\n","import Assert from '../util/Assert.js'\nexport default class SegmentPointComparator {\n  static relativeSign(x0, x1) {\n    if (x0 < x1) return -1\n    if (x0 > x1) return 1\n    return 0\n  }\n  static compareValue(compareSign0, compareSign1) {\n    if (compareSign0 < 0) return -1\n    if (compareSign0 > 0) return 1\n    if (compareSign1 < 0) return -1\n    if (compareSign1 > 0) return 1\n    return 0\n  }\n  static compare(octant, p0, p1) {\n    if (p0.equals2D(p1)) return 0\n    const xSign = SegmentPointComparator.relativeSign(p0.x, p1.x)\n    const ySign = SegmentPointComparator.relativeSign(p0.y, p1.y)\n    switch (octant) {\n    case 0:\n      return SegmentPointComparator.compareValue(xSign, ySign)\n    case 1:\n      return SegmentPointComparator.compareValue(ySign, xSign)\n    case 2:\n      return SegmentPointComparator.compareValue(ySign, -xSign)\n    case 3:\n      return SegmentPointComparator.compareValue(-xSign, ySign)\n    case 4:\n      return SegmentPointComparator.compareValue(-xSign, -ySign)\n    case 5:\n      return SegmentPointComparator.compareValue(-ySign, -xSign)\n    case 6:\n      return SegmentPointComparator.compareValue(-ySign, xSign)\n    case 7:\n      return SegmentPointComparator.compareValue(xSign, -ySign)\n    }\n    Assert.shouldNeverReachHere('invalid octant value')\n    return 0\n  }\n}\n","import Coordinate from '../geom/Coordinate.js'\nimport SegmentPointComparator from './SegmentPointComparator.js'\nimport Comparable from '../../../../java/lang/Comparable.js'\nexport default class SegmentNode {\n  constructor() {\n    SegmentNode.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._segString = null\n    this.coord = null\n    this.segmentIndex = null\n    this._segmentOctant = null\n    this._isInterior = null\n    const segString = arguments[0], coord = arguments[1], segmentIndex = arguments[2], segmentOctant = arguments[3]\n    this._segString = segString\n    this.coord = new Coordinate(coord)\n    this.segmentIndex = segmentIndex\n    this._segmentOctant = segmentOctant\n    this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex))\n  }\n  getCoordinate() {\n    return this.coord\n  }\n  print(out) {\n    out.print(this.coord)\n    out.print(' seg # = ' + this.segmentIndex)\n  }\n  compareTo(obj) {\n    const other = obj\n    if (this.segmentIndex < other.segmentIndex) return -1\n    if (this.segmentIndex > other.segmentIndex) return 1\n    if (this.coord.equals2D(other.coord)) return 0\n    if (!this._isInterior) return -1\n    if (!other._isInterior) return 1\n    return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)\n  }\n  isEndPoint(maxSegmentIndex) {\n    if (this.segmentIndex === 0 && !this._isInterior) return true\n    if (this.segmentIndex === maxSegmentIndex) return true\n    return false\n  }\n  toString() {\n    return this.segmentIndex + ':' + this.coord.toString()\n  }\n  isInterior() {\n    return this._isInterior\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import Map from './Map.js'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n */\nexport default class SortedMap extends Map {}\n","import ArrayList from './ArrayList.js'\nimport SortedMap from './SortedMap.js'\nimport HashSet from './HashSet.js'\n\nconst BLACK = 0\nconst RED = 1\n\nfunction colorOf(p) {\n  return (p == null ? BLACK : p.color)\n}\nfunction parentOf(p) {\n  return (p == null ? null : p.parent)\n}\nfunction setColor(p, c) {\n  if (p !== null) p.color = c\n}\nfunction leftOf(p) {\n  return (p == null ? null : p.left)\n}\nfunction rightOf(p) {\n  return (p == null ? null : p.right)\n}\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n */\nexport default class TreeMap extends SortedMap {\n  constructor() {\n    super()\n    this.root_ = null\n    this.size_ = 0\n  }\n\n  get(key) {\n    let p = this.root_\n    while (p !== null) {\n      const cmp = key.compareTo(p.key)\n      if (cmp < 0)\n        p = p.left\n      else if (cmp > 0)\n        p = p.right\n      else return p.value\n    }\n    return null\n  }\n\n  put(key, value) {\n    if (this.root_ === null) {\n      this.root_ = {\n        key: key,\n        value: value,\n        left: null,\n        right: null,\n        parent: null,\n        color: BLACK,\n        getValue() {\n          return this.value\n        },\n        getKey() {\n          return this.key\n        }\n      }\n      this.size_ = 1\n      return null\n    }\n    let t = this.root_; let parent; let cmp\n    do {\n      parent = t\n      cmp = key.compareTo(t.key)\n      if (cmp < 0) {\n        t = t.left\n      } else if (cmp > 0) {\n        t = t.right\n      } else {\n        const oldValue = t.value\n        t.value = value\n        return oldValue\n      }\n    } while (t !== null)\n    const e = {\n      key: key,\n      left: null,\n      right: null,\n      value: value,\n      parent: parent,\n      color: BLACK,\n      getValue() {\n        return this.value\n      },\n      getKey() {\n        return this.key\n      }\n    }\n    if (cmp < 0)\n      parent.left = e\n    else parent.right = e\n\n    this.fixAfterInsertion(e)\n    this.size_++\n    return null\n  }\n\n  /**\n   * @param {Object} x\n   */\n  fixAfterInsertion(x) {\n    let y\n    x.color = RED\n    while (x != null && x !== this.root_ && x.parent.color === RED)\n      if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {\n        y = rightOf(parentOf(parentOf(x)))\n        if (colorOf(y) === RED) {\n          setColor(parentOf(x), BLACK)\n          setColor(y, BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          x = parentOf(parentOf(x))\n        } else {\n          if (x === rightOf(parentOf(x))) {\n            x = parentOf(x)\n            this.rotateLeft(x)\n          }\n          setColor(parentOf(x), BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          this.rotateRight(parentOf(parentOf(x)))\n        }\n      } else {\n        y = leftOf(parentOf(parentOf(x)))\n        if (colorOf(y) === RED) {\n          setColor(parentOf(x), BLACK)\n          setColor(y, BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          x = parentOf(parentOf(x))\n        } else {\n          if (x === leftOf(parentOf(x))) {\n            x = parentOf(x)\n            this.rotateRight(x)\n          }\n          setColor(parentOf(x), BLACK)\n          setColor(parentOf(parentOf(x)), RED)\n          this.rotateLeft(parentOf(parentOf(x)))\n        }\n      }\n\n    this.root_.color = BLACK\n  }\n\n  values() {\n    const arrayList = new ArrayList()\n    let p = this.getFirstEntry()\n    if (p !== null) {\n      arrayList.add(p.value)\n      while ((p = TreeMap.successor(p)) !== null)\n        arrayList.add(p.value)\n    }\n    return arrayList\n  }\n\n  entrySet() {\n    const hashSet = new HashSet()\n    let p = this.getFirstEntry()\n    if (p !== null) {\n      hashSet.add(p)\n      while ((p = TreeMap.successor(p)) !== null)\n        hashSet.add(p)\n    }\n    return hashSet\n  }\n\n  /**\n   * @param {Object} p\n   */\n  rotateLeft(p) {\n    if (p != null) {\n      const r = p.right\n      p.right = r.left\n      if (r.left != null)\n        r.left.parent = p\n      r.parent = p.parent\n      if (p.parent == null)\n        this.root_ = r\n      else if (p.parent.left === p)\n        p.parent.left = r\n      else\n        p.parent.right = r\n      r.left = p\n      p.parent = r\n    }\n  }\n\n  /**\n   * @param {Object} p\n   */\n  rotateRight(p) {\n    if (p != null) {\n      const l = p.left\n      p.left = l.right\n      if (l.right != null)\n        l.right.parent = p\n      l.parent = p.parent\n      if (p.parent == null)\n        this.root_ = l\n      else if (p.parent.right === p)\n        p.parent.right = l\n      else\n        p.parent.left = l\n      l.right = p\n      p.parent = l\n    }\n  }\n\n  /**\n   * @return {Object}\n   */\n  getFirstEntry() {\n    let p = this.root_\n    if (p != null)\n      while (p.left != null) p = p.left\n    return p\n  }\n\n  /**\n   * @param {Object} t\n   * @return {Object}\n   * @private\n   */\n  static successor(t) {\n    let p\n    if (t === null) {\n      return null\n    } else if (t.right !== null) {\n      p = t.right\n      while (p.left !== null)\n        p = p.left\n      return p\n    } else {\n      p = t.parent\n      let ch = t\n      while (p !== null && ch === p.right) {\n        ch = p\n        p = p.parent\n      }\n      return p\n    }\n  }\n\n  size() {\n    return this.size_\n  }\n\n  containsKey(key) {\n    let p = this.root_\n    while (p !== null) {\n      const cmp = key.compareTo(p.key)\n      if (cmp < 0)\n        p = p.left\n      else if (cmp > 0)\n        p = p.right\n      else return true\n    }\n    return false\n  }\n}\n","import CoordinateList from '../geom/CoordinateList.js'\nimport SegmentNode from './SegmentNode.js'\nimport Iterator from '../../../../java/util/Iterator.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport NodedSegmentString from './NodedSegmentString.js'\nimport Integer from '../../../../java/lang/Integer.js'\nimport UnsupportedOperationException from '../../../../java/lang/UnsupportedOperationException.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport TreeMap from '../../../../java/util/TreeMap.js'\nimport RuntimeException from '../../../../java/lang/RuntimeException.js'\nimport Assert from '../util/Assert.js'\nexport default class SegmentNodeList {\n  constructor() {\n    SegmentNodeList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeMap = new TreeMap()\n    this._edge = null\n    const edge = arguments[0]\n    this._edge = edge\n  }\n  getSplitCoordinates() {\n    const coordList = new CoordinateList()\n    this.addEndpoints()\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      this.addEdgeCoordinates(eiPrev, ei, coordList)\n      eiPrev = ei\n    }\n    return coordList.toCoordinateArray()\n  }\n  print(out) {\n    out.println('Intersections:')\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ei = it.next()\n      ei.print(out)\n    }\n  }\n  findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n    for (let i = 0; i < this._edge.size() - 2; i++) {\n      const p0 = this._edge.getCoordinate(i)\n      const p1 = this._edge.getCoordinate(i + 1)\n      const p2 = this._edge.getCoordinate(i + 2)\n      if (p0.equals2D(p2)) \n        collapsedVertexIndexes.add(Integer.valueOf(i + 1))\n      \n    }\n  }\n  addEdgeCoordinates(ei0, ei1, coordList) {\n    const pts = this.createSplitEdgePts(ei0, ei1)\n    coordList.add(pts, false)\n  }\n  findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n    if (!ei0.coord.equals2D(ei1.coord)) return false\n    let numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex\n    if (!ei1.isInterior()) \n      numVerticesBetween--\n    \n    if (numVerticesBetween === 1) {\n      collapsedVertexIndex[0] = ei0.segmentIndex + 1\n      return true\n    }\n    return false\n  }\n  findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n    const collapsedVertexIndex = new Array(1).fill(null)\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      const isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex)\n      if (isCollapsed) collapsedVertexIndexes.add(Integer.valueOf(collapsedVertexIndex[0]))\n      eiPrev = ei\n    }\n  }\n  getEdge() {\n    return this._edge\n  }\n  addEndpoints() {\n    const maxSegIndex = this._edge.size() - 1\n    this.add(this._edge.getCoordinate(0), 0)\n    this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex)\n  }\n  createSplitEdge(ei0, ei1) {\n    const pts = this.createSplitEdgePts(ei0, ei1)\n    return new NodedSegmentString(pts, this._edge.getData())\n  }\n  add(intPt, segmentIndex) {\n    const eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex))\n    const ei = this._nodeMap.get(eiNew)\n    if (ei !== null) {\n      Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates')\n      return ei\n    }\n    this._nodeMap.put(eiNew, eiNew)\n    return eiNew\n  }\n  checkSplitEdgesCorrectness(splitEdges) {\n    const edgePts = this._edge.getCoordinates()\n    const split0 = splitEdges.get(0)\n    const pt0 = split0.getCoordinate(0)\n    if (!pt0.equals2D(edgePts[0])) throw new RuntimeException('bad split edge start point at ' + pt0)\n    const splitn = splitEdges.get(splitEdges.size() - 1)\n    const splitnPts = splitn.getCoordinates()\n    const ptn = splitnPts[splitnPts.length - 1]\n    if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException('bad split edge end point at ' + ptn)\n  }\n  addCollapsedNodes() {\n    const collapsedVertexIndexes = new ArrayList()\n    this.findCollapsesFromInsertedNodes(collapsedVertexIndexes)\n    this.findCollapsesFromExistingVertices(collapsedVertexIndexes)\n    for (let it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {\n      const vertexIndex = it.next().intValue()\n      this.add(this._edge.getCoordinate(vertexIndex), vertexIndex)\n    }\n  }\n  createSplitEdgePts(ei0, ei1) {\n    let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n    if (npts === 2) return [new Coordinate(ei0.coord), new Coordinate(ei1.coord)]\n    const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex)\n    const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt)\n    if (!useIntPt1) \n      npts--\n    \n    const pts = new Array(npts).fill(null)\n    let ipt = 0\n    pts[ipt++] = new Coordinate(ei0.coord)\n    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) \n      pts[ipt++] = this._edge.getCoordinate(i)\n    \n    if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord)\n    return pts\n  }\n  iterator() {\n    return this._nodeMap.values().iterator()\n  }\n  addSplitEdges(edgeList) {\n    this.addEndpoints()\n    this.addCollapsedNodes()\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      const newEdge = this.createSplitEdge(eiPrev, ei)\n      edgeList.add(newEdge)\n      eiPrev = ei\n    }\n  }\n}\nclass NodeVertexIterator {\n  constructor() {\n    NodeVertexIterator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeList = null\n    this._edge = null\n    this._nodeIt = null\n    this._currNode = null\n    this._nextNode = null\n    this._currSegIndex = 0\n    const nodeList = arguments[0]\n    this._nodeList = nodeList\n    this._edge = nodeList.getEdge()\n    this._nodeIt = nodeList.iterator()\n    this.readNextNode()\n  }\n  next() {\n    if (this._currNode === null) {\n      this._currNode = this._nextNode\n      this._currSegIndex = this._currNode.segmentIndex\n      this.readNextNode()\n      return this._currNode\n    }\n    if (this._nextNode === null) return null\n    if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n      this._currNode = this._nextNode\n      this._currSegIndex = this._currNode.segmentIndex\n      this.readNextNode()\n      return this._currNode\n    }\n    if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n    return null\n  }\n  readNextNode() {\n    if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null\n  }\n  hasNext() {\n    if (this._nextNode === null) return false\n    return true\n  }\n  remove() {\n    throw new UnsupportedOperationException(this.getClass().getName())\n  }\n  get interfaces_() {\n    return [Iterator]\n  }\n}\n","import Coordinate from '../geom/Coordinate.js'\nimport GeometryFactory from '../geom/GeometryFactory.js'\n\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nconst GeometryLayout = {\n  XY: 'XY',\n  XYZ: 'XYZ',\n  XYM: 'XYM',\n  XYZM: 'XYZM',\n}\n\n/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\nconst GeometryType = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  LINEAR_RING: 'LinearRing',\n  POLYGON: 'Polygon',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon',\n  GEOMETRY_COLLECTION: 'GeometryCollection',\n  CIRCLE: 'Circle',\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n * multiple features on reading.\n */\n\n/**\n * @typedef {Object} Token\n * @property {number} type\n * @property {number|string} [value]\n * @property {number} position\n */\n\n/**\n * @const\n * @type {string}\n */\nconst EMPTY = 'EMPTY'\n\n/**\n * @const\n * @type {string}\n */\nconst Z = 'Z'\n\n/**\n * @const\n * @type {string}\n */\nconst M = 'M'\n\n/**\n * @const\n * @type {string}\n */\nconst ZM = 'ZM'\n\n/**\n * @const\n * @enum {number}\n */\nconst TokenType = {\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6,\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst WKTGeometryType = {}\nfor (const type in GeometryType)\n  WKTGeometryType[type] = GeometryType[type].toUpperCase()\n\n\n/**\n * Class to tokenize a WKT string.\n */\nclass Lexer {\n  /**\n   * @param {string} wkt WKT string.\n   */\n  constructor(wkt) {\n    /**\n     * @type {string}\n     */\n    this.wkt = wkt\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.index_ = -1\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is alphabetic.\n   * @private\n   */\n  isAlpha_(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n  }\n\n  /**\n   * @param {string} c Character.\n   * @param {boolean=} opt_decimal Whether the string number\n   *     contains a dot, i.e. is a decimal number.\n   * @return {boolean} Whether the character is numeric.\n   * @private\n   */\n  isNumeric_(c, opt_decimal) {\n    const decimal = opt_decimal !== undefined ? opt_decimal : false\n    return (c >= '0' && c <= '9') || (c == '.' && !decimal)\n  }\n\n  /**\n   * @param {string} c Character.\n   * @return {boolean} Whether the character is whitespace.\n   * @private\n   */\n  isWhiteSpace_(c) {\n    return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n'\n  }\n\n  /**\n   * @return {string} Next string character.\n   * @private\n   */\n  nextChar_() {\n    return this.wkt.charAt(++this.index_)\n  }\n\n  /**\n   * Fetch and return the next token.\n   * @return {!Token} Next string token.\n   */\n  nextToken() {\n    const c = this.nextChar_()\n    const position = this.index_\n    /** @type {number|string} */\n    let value = c\n    let type\n\n    if (c == '(') {\n      type = TokenType.LEFT_PAREN\n    } else if (c == ',') {\n      type = TokenType.COMMA\n    } else if (c == ')') {\n      type = TokenType.RIGHT_PAREN\n    } else if (this.isNumeric_(c) || c == '-') {\n      type = TokenType.NUMBER\n      value = this.readNumber_()\n    } else if (this.isAlpha_(c)) {\n      type = TokenType.TEXT\n      value = this.readText_()\n    } else if (this.isWhiteSpace_(c)) {\n      return this.nextToken()\n    } else if (c === '') {\n      type = TokenType.EOF\n    } else {\n      throw new Error('Unexpected character: ' + c)\n    }\n\n    return { position: position, value: value, type: type }\n  }\n\n  /**\n   * @return {number} Numeric token value.\n   * @private\n   */\n  readNumber_() {\n    let c\n    const index = this.index_\n    let decimal = false\n    let scientificNotation = false\n    do {\n      if (c == '.')\n        decimal = true\n      else if (c == 'e' || c == 'E')\n        scientificNotation = true\n      c = this.nextChar_()\n    } while (\n      this.isNumeric_(c, decimal) ||\n      // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      (!scientificNotation && (c == 'e' || c == 'E')) ||\n      // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      (scientificNotation && (c == '-' || c == '+'))\n    )\n    return parseFloat(this.wkt.substring(index, this.index_--))\n  }\n\n  /**\n   * @return {string} String token value.\n   * @private\n   */\n  readText_() {\n    let c\n    const index = this.index_\n    do\n      c = this.nextChar_()\n    while (this.isAlpha_(c))\n    return this.wkt.substring(index, this.index_--).toUpperCase()\n  }\n}\n\n/**\n * Class to parse the tokens from the WKT string.\n */\nclass Parser {\n  /**\n   * @param {Lexer} lexer The lexer.\n   */\n  constructor(lexer, factory) {\n    /**\n     * @type {Lexer}\n     * @private\n     */\n    this.lexer_ = lexer\n\n    /**\n     * @type {Token}\n     * @private\n     */\n    this.token_\n\n    /**\n     * @type {import(\"../geom/GeometryLayout.js\").default}\n     * @private\n     */\n    this.layout_ = GeometryLayout.XY\n\n    this.factory = factory\n  }\n\n  /**\n   * Fetch the next token form the lexer and replace the active token.\n   * @private\n   */\n  consume_() {\n    this.token_ = this.lexer_.nextToken()\n  }\n\n  /**\n   * Tests if the given type matches the type of the current token.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  isTokenType(type) {\n    const isMatch = this.token_.type == type\n    return isMatch\n  }\n\n  /**\n   * If the given type matches the current token, consume it.\n   * @param {TokenType} type Token type.\n   * @return {boolean} Whether the token matches the given type.\n   */\n  match(type) {\n    const isMatch = this.isTokenType(type)\n    if (isMatch) \n      this.consume_()\n    return isMatch\n  }\n\n  /**\n   * Try to parse the tokens provided by the lexer.\n   * @return {import(\"../geom/Geometry.js\").default} The geometry.\n   */\n  parse() {\n    this.consume_()\n    const geometry = this.parseGeometry_()\n    return geometry\n  }\n\n  /**\n   * Try to parse the dimensional info.\n   * @return {import(\"../geom/GeometryLayout.js\").default} The layout.\n   * @private\n   */\n  parseGeometryLayout_() {\n    let layout = GeometryLayout.XY\n    const dimToken = this.token_\n    if (this.isTokenType(TokenType.TEXT)) {\n      const dimInfo = dimToken.value\n      if (dimInfo === Z)\n        layout = GeometryLayout.XYZ\n      else if (dimInfo === M)\n        layout = GeometryLayout.XYM\n      else if (dimInfo === ZM)\n        layout = GeometryLayout.XYZM\n      if (layout !== GeometryLayout.XY)\n        this.consume_()\n    }\n    return layout\n  }\n\n  /**\n   * @return {!Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n   * @private\n   */\n  parseGeometryCollectionText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const geometries = []\n      do\n        geometries.push(this.parseGeometry_())\n      while (this.match(TokenType.COMMA))\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return geometries\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {Array<number>} All values in a point.\n   * @private\n   */\n  parsePointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePoint_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return null\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} All points in a linestring.\n   * @private\n   */\n  parseLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePointList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<number>>>} All points in a polygon.\n   * @private\n   */\n  parsePolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} All points in a multipoint.\n   * @private\n   */\n  parseMultiPointText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      let coordinates\n      if (this.token_.type == TokenType.LEFT_PAREN) \n        coordinates = this.parsePointTextList_()\n      else\n        coordinates = this.parsePointList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<number>>>} All linestring points\n   *                                          in a multilinestring.\n   * @private\n   */\n  parseMultiLineStringText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parseLineStringTextList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.\n   * @private\n   */\n  parseMultiPolygonText_() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      const coordinates = this.parsePolygonTextList_()\n      if (this.match(TokenType.RIGHT_PAREN)) \n        return coordinates\n    } else if (this.isEmptyGeometry_()) {\n      return []\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<number>} A point.\n   * @private\n   */\n  parsePoint_() {\n    const coordinates = []\n    const dimensions = this.layout_.length\n    for (let i = 0; i < dimensions; ++i) {\n      const token = this.token_\n      if (this.match(TokenType.NUMBER)) \n        coordinates.push(/** @type {number} */(token.value))\n      else\n        break\n    }\n    if (coordinates.length == dimensions) \n      return coordinates\n    throw new Error(this.formatErrorMessage_())\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} An array of points.\n   * @private\n   */\n  parsePointList_() {\n    const coordinates = [this.parsePoint_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parsePoint_())\n    return coordinates\n  }\n\n  /**\n   * @return {!Array<!Array<number>>} An array of points.\n   * @private\n   */\n  parsePointTextList_() {\n    const coordinates = [this.parsePointText_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parsePointText_())\n    return coordinates\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<number>>>} An array of points.\n   * @private\n   */\n  parseLineStringTextList_() {\n    const coordinates = [this.parseLineStringText_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parseLineStringText_())\n    return coordinates\n  }\n\n  /**\n   * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.\n   * @private\n   */\n  parsePolygonTextList_() {\n    const coordinates = [this.parsePolygonText_()]\n    while (this.match(TokenType.COMMA))\n      coordinates.push(this.parsePolygonText_())\n    return coordinates\n  }\n\n  /**\n   * @return {boolean} Whether the token implies an empty geometry.\n   * @private\n   */\n  isEmptyGeometry_() {\n    const isEmpty =\n      this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY\n    if (isEmpty)\n      this.consume_()\n    return isEmpty\n  }\n\n  /**\n   * Create an error message for an unexpected token error.\n   * @return {string} Error message.\n   * @private\n   */\n  formatErrorMessage_() {\n    return (\n      'Unexpected `' +\n      this.token_.value +\n      '` at position ' +\n      this.token_.position +\n      ' in `' +\n      this.lexer_.wkt +\n      '`'\n    )\n  }\n\n  /**\n   * @return {!import(\"../geom/Geometry.js\").default} The geometry.\n   * @private\n   */\n  parseGeometry_() {\n    const factory = this.factory\n\n    const o2c = ordinates => ordinates ? new Coordinate(...ordinates) : new Coordinate()\n    const ca2p = coordinates => {\n      const rings = coordinates.map(a => factory.createLinearRing(a.map(o2c)))\n      if (rings.length > 1)\n        return factory.createPolygon(rings[0], rings.slice(1))\n      else if (rings.length === 1)\n        return factory.createPolygon(rings[0])\n      else\n        return factory.createPolygon()\n    }\n\n    const token = this.token_\n    if (this.match(TokenType.TEXT)) {\n      const geomType = token.value\n      this.layout_ = this.parseGeometryLayout_()\n      if (geomType == 'GEOMETRYCOLLECTION') {\n        const geometries = this.parseGeometryCollectionText_()\n        return factory.createGeometryCollection(geometries)\n      } else {\n        switch (geomType) {\n        case 'POINT': {\n          const ordinates = this.parsePointText_()\n          if (!ordinates)\n            return factory.createPoint()\n          return factory.createPoint(new Coordinate(...ordinates))\n        }\n        case 'LINESTRING': {\n          const coordinates = this.parseLineStringText_()\n          const components = coordinates.map(o2c)\n          return factory.createLineString(components)\n        }\n        case 'LINEARRING': {\n          const coordinates = this.parseLineStringText_()\n          const components = coordinates.map(o2c)\n          return factory.createLinearRing(components)\n        }\n        case 'POLYGON': {\n          const coordinates = this.parsePolygonText_()\n          if (!coordinates || coordinates.length === 0)\n            return factory.createPolygon()\n          return ca2p(coordinates)\n        }\n        case 'MULTIPOINT': {\n          const coordinates = this.parseMultiPointText_()\n          if (!coordinates || coordinates.length === 0)\n            return factory.createMultiPoint()\n          const components = coordinates.map(o2c).map(c => factory.createPoint(c))\n          return factory.createMultiPoint(components)\n        }\n        case 'MULTILINESTRING': {\n          const coordinates = this.parseMultiLineStringText_()\n          const components = coordinates.map(a => factory.createLineString(a.map(o2c)))\n          return factory.createMultiLineString(components)\n        }\n        case 'MULTIPOLYGON': {\n          const coordinates = this.parseMultiPolygonText_()\n          if (!coordinates || coordinates.length === 0)\n            return factory.createMultiPolygon()\n          const polygons = coordinates.map(ca2p)\n          return factory.createMultiPolygon(polygons)\n        }\n        default: {\n          throw new Error('Invalid geometry type: ' + geomType)\n        }\n        }\n      }\n    }\n    throw new Error(this.formatErrorMessage_())\n  }\n}\n\n/**\n * @param {Point} geom Point geometry.\n * @return {string} Coordinates part of Point as WKT.\n */\nfunction encodePointGeometry(geom) {\n  if (geom.isEmpty())\n    return ''\n  const c = geom.getCoordinate()\n  const cs = [c.x, c.y]\n  if (c.z !== undefined && !Number.isNaN(c.z))\n    cs.push(c.z)\n  if (c.m !== undefined && !Number.isNaN(c.m))\n    cs.push(c.m)\n  return cs.join(' ')\n}\n\n/**\n * @param {MultiPoint} geom MultiPoint geometry.\n * @return {string} Coordinates part of MultiPoint as WKT.\n */\nfunction encodeMultiPointGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push('(' + encodePointGeometry(geom.getGeometryN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {GeometryCollection} geom GeometryCollection geometry.\n * @return {string} Coordinates part of GeometryCollection as WKT.\n */\nfunction encodeGeometryCollectionGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push(encode(geom.getGeometryN(i)))\n  return array.join(', ')\n}\n\n/**\n * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n * @return {string} Coordinates part of LineString as WKT.\n */\nfunction encodeLineStringGeometry(geom) {\n  const coordinates = geom.getCoordinates()\n    .map(c => {\n      const a = [c.x, c.y]\n      if (c.z !== undefined && !Number.isNaN(c.z))\n        a.push(c.z)\n      if (c.m !== undefined && !Number.isNaN(c.m))\n        a.push(c.m)\n      return a\n    })\n  const array = []\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) \n    array.push(coordinates[i].join(' '))\n  return array.join(', ')\n}\n\n/**\n * @param {MultiLineString} geom MultiLineString geometry.\n * @return {string} Coordinates part of MultiLineString as WKT.\n */\nfunction encodeMultiLineStringGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push('(' + encodeLineStringGeometry(geom.getGeometryN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {Polygon} geom Polygon geometry.\n * @return {string} Coordinates part of Polygon as WKT.\n */\nfunction encodePolygonGeometry(geom) {\n  const array = []\n  array.push('(' + encodeLineStringGeometry(geom.getExteriorRing()) + ')')\n  for (let i = 0, ii = geom.getNumInteriorRing(); i < ii; ++i) \n    array.push('(' + encodeLineStringGeometry(geom.getInteriorRingN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {MultiPolygon} geom MultiPolygon geometry.\n * @return {string} Coordinates part of MultiPolygon as WKT.\n */\nfunction encodeMultiPolygonGeometry(geom) {\n  const array = []\n  for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) \n    array.push('(' + encodePolygonGeometry(geom.getGeometryN(i)) + ')')\n  return array.join(', ')\n}\n\n/**\n * @param {Geometry} geom Geometry geometry.\n * @return {string} Potential dimensional information for WKT type.\n */\nfunction encodeGeometryLayout(geom) {\n  let dimInfo = ''\n  if (geom.isEmpty())\n    return dimInfo\n  const c = geom.getCoordinate()\n  if (c.z !== undefined && !Number.isNaN(c.z))\n    dimInfo += Z\n  if (c.m !== undefined && !Number.isNaN(c.m))\n    dimInfo += M\n  return dimInfo\n}\n\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n */\nconst GeometryEncoder = {\n  'Point': encodePointGeometry,\n  'LineString': encodeLineStringGeometry,\n  'LinearRing': encodeLineStringGeometry,\n  'Polygon': encodePolygonGeometry,\n  'MultiPoint': encodeMultiPointGeometry,\n  'MultiLineString': encodeMultiLineStringGeometry,\n  'MultiPolygon': encodeMultiPolygonGeometry,\n  'GeometryCollection': encodeGeometryCollectionGeometry,\n}\n\n/**\n * Encode a geometry as WKT.\n * @param {!import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n * @return {string} WKT string for the geometry.\n */\nfunction encode(geom) {\n  let type = geom.getGeometryType()\n  const geometryEncoder = GeometryEncoder[type]\n  type = type.toUpperCase()\n  const dimInfo = encodeGeometryLayout(geom)\n  if (dimInfo.length > 0) \n    type += ' ' + dimInfo\n  if (geom.isEmpty()) \n    return type + ' ' + EMPTY\n  const enc = geometryEncoder(geom)\n  return type + ' (' + enc + ')'\n}\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers.\n */\n\nexport default class WKTParser {\n  /** Create a new parser for WKT\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of WKTParser.\n   * @private\n   */\n  constructor(geometryFactory) {\n    this.geometryFactory = geometryFactory || new GeometryFactory()\n    this.precisionModel = this.geometryFactory.getPrecisionModel()\n  }\n\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read(wkt) {\n    const lexer = new Lexer(wkt)\n    const parser = new Parser(lexer, this.geometryFactory)\n    const geometry = parser.parse()\n    return geometry\n  }\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write(geometry) {\n    return encode(geometry)\n  }\n}\n","/**\n * @module org/locationtech/jts/io/WKTWriter\n */\n\nimport WKTParser from './WKTParser.js'\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\nexport default class WKTWriter {\n  /**\n   * @param {GeometryFactory} geometryFactory\n   */\n  constructor(geometryFactory) {\n    this.parser = new WKTParser(geometryFactory)\n  }\n\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof module:org/locationtech/jts/io/WKTWriter#\n   */\n  write(geometry) {\n    return this.parser.write(geometry)\n  }\n\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  static toLineString(p0, p1) {\n    if (arguments.length !== 2) throw new Error('Not implemented')\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n  }\n}\n","import Coordinate from '../geom/Coordinate.js'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException.js'\nexport default class Octant {\n  static octant() {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      const dx = arguments[0], dy = arguments[1]\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )')\n      const adx = Math.abs(dx)\n      const ady = Math.abs(dy)\n      if (dx >= 0) \n        if (dy >= 0) \n          if (adx >= ady) return 0; else return 1\n        else \n          if (adx >= ady) return 7; else return 6\n        \n      else \n        if (dy >= 0) \n          if (adx >= ady) return 3; else return 2\n        else \n          if (adx >= ady) return 4; else return 5\n        \n      \n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      const p0 = arguments[0], p1 = arguments[1]\n      const dx = p1.x - p0.x\n      const dy = p1.y - p0.y\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0)\n      return Octant.octant(dx, dy)\n    }\n  }\n}\n","export default class SegmentString {\n  getCoordinates() {}\n  size() {}\n  getCoordinate(i) {}\n  isClosed() {}\n  setData(data) {}\n  getData() {}\n}\n","import SegmentString from './SegmentString.js'\nexport default class NodableSegmentString {\n  addIntersection(intPt, segmentIndex) {}\n  get interfaces_() {\n    return [SegmentString]\n  }\n}\n","import SegmentNodeList from './SegmentNodeList.js'\nimport WKTWriter from '../io/WKTWriter.js'\nimport CoordinateArraySequence from '../geom/impl/CoordinateArraySequence.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Octant from './Octant.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport NodableSegmentString from './NodableSegmentString.js'\nexport default class NodedSegmentString {\n  constructor() {\n    NodedSegmentString.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeList = new SegmentNodeList(this)\n    this._pts = null\n    this._data = null\n    const pts = arguments[0], data = arguments[1]\n    this._pts = pts\n    this._data = data\n  }\n  static getNodedSubstrings() {\n    if (arguments.length === 1) {\n      const segStrings = arguments[0]\n      const resultEdgelist = new ArrayList()\n      NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist)\n      return resultEdgelist\n    } else if (arguments.length === 2) {\n      const segStrings = arguments[0], resultEdgelist = arguments[1]\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        ss.getNodeList().addSplitEdges(resultEdgelist)\n      }\n    }\n  }\n  getCoordinates() {\n    return this._pts\n  }\n  size() {\n    return this._pts.length\n  }\n  getCoordinate(i) {\n    return this._pts[i]\n  }\n  isClosed() {\n    return this._pts[0].equals(this._pts[this._pts.length - 1])\n  }\n  getSegmentOctant(index) {\n    if (index === this._pts.length - 1) return -1\n    return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))\n  }\n  toString() {\n    return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n  }\n  getNodeList() {\n    return this._nodeList\n  }\n  addIntersectionNode(intPt, segmentIndex) {\n    let normalizedSegmentIndex = segmentIndex\n    const nextSegIndex = normalizedSegmentIndex + 1\n    if (nextSegIndex < this._pts.length) {\n      const nextPt = this._pts[nextSegIndex]\n      if (intPt.equals2D(nextPt)) \n        normalizedSegmentIndex = nextSegIndex\n      \n    }\n    const ei = this._nodeList.add(intPt, normalizedSegmentIndex)\n    return ei\n  }\n  addIntersections(li, segmentIndex, geomIndex) {\n    for (let i = 0; i < li.getIntersectionNum(); i++) \n      this.addIntersection(li, segmentIndex, geomIndex, i)\n    \n  }\n  setData(data) {\n    this._data = data\n  }\n  safeOctant(p0, p1) {\n    if (p0.equals2D(p1)) return 0\n    return Octant.octant(p0, p1)\n  }\n  getData() {\n    return this._data\n  }\n  addIntersection() {\n    if (arguments.length === 2) {\n      const intPt = arguments[0], segmentIndex = arguments[1]\n      this.addIntersectionNode(intPt, segmentIndex)\n    } else if (arguments.length === 4) {\n      const li = arguments[0], segmentIndex = arguments[1], geomIndex = arguments[2], intIndex = arguments[3]\n      const intPt = new Coordinate(li.getIntersection(intIndex))\n      this.addIntersection(intPt, segmentIndex)\n    }\n  }\n  get interfaces_() {\n    return [NodableSegmentString]\n  }\n}\n","export default class Noder {\n  getNodedSubstrings() {}\n  computeNodes(segStrings) {}\n}\n","import hasInterface from '../../../../hasInterface.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport NodedSegmentString from './NodedSegmentString.js'\nimport System from '../../../../java/lang/System.js'\nimport CoordinateArrays from '../geom/CoordinateArrays.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport Collection from '../../../../java/util/Collection.js'\nimport Noder from './Noder.js'\nexport default class ScaledNoder {\n  constructor() {\n    ScaledNoder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._noder = null\n    this._scaleFactor = null\n    this._offsetX = null\n    this._offsetY = null\n    this._isScaled = false\n    if (arguments.length === 2) {\n      const noder = arguments[0], scaleFactor = arguments[1]\n      ScaledNoder.constructor_.call(this, noder, scaleFactor, 0, 0)\n    } else if (arguments.length === 4) {\n      const noder = arguments[0], scaleFactor = arguments[1], offsetX = arguments[2], offsetY = arguments[3]\n      this._noder = noder\n      this._scaleFactor = scaleFactor\n      this._isScaled = !this.isIntegerPrecision()\n    }\n  }\n  rescale() {\n    if (hasInterface(arguments[0], Collection)) {\n      const segStrings = arguments[0]\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        this.rescale(ss.getCoordinates())\n      }\n    } else if (arguments[0] instanceof Array) {\n      const pts = arguments[0]\n      for (let i = 0; i < pts.length; i++) {\n        pts[i].x = pts[i].x / this._scaleFactor + this._offsetX\n        pts[i].y = pts[i].y / this._scaleFactor + this._offsetY\n      }\n      if (pts.length === 2 && pts[0].equals2D(pts[1])) \n        System.out.println(pts)\n      \n    }\n  }\n  scale() {\n    if (hasInterface(arguments[0], Collection)) {\n      const segStrings = arguments[0]\n      const nodedSegmentStrings = new ArrayList(segStrings.size())\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()))\n      }\n      return nodedSegmentStrings\n    } else if (arguments[0] instanceof Array) {\n      const pts = arguments[0]\n      const roundPts = new Array(pts.length).fill(null)\n      for (let i = 0; i < pts.length; i++) \n        roundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].getZ())\n      \n      const roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts)\n      return roundPtsNoDup\n    }\n  }\n  isIntegerPrecision() {\n    return this._scaleFactor === 1.0\n  }\n  getNodedSubstrings() {\n    const splitSS = this._noder.getNodedSubstrings()\n    if (this._isScaled) this.rescale(splitSS)\n    return splitSS\n  }\n  computeNodes(inputSegStrings) {\n    let intSegStrings = inputSegStrings\n    if (this._isScaled) intSegStrings = this.scale(inputSegStrings)\n    this._noder.computeNodes(intSegStrings)\n  }\n  get interfaces_() {\n    return [Noder]\n  }\n}\n","import Coordinate from './Coordinate.js'\nimport RuntimeException from '../../../../java/lang/RuntimeException.js'\n\nexport default class TopologyException extends RuntimeException {\n  constructor(msg, pt) {\n    super(pt ? msg + ' [ ' + pt + ' ]' : msg)\n    this.pt = pt ? new Coordinate(pt) : undefined\n    this.name = Object.keys({ TopologyException })[0]\n  }\n  getCoordinate() {\n    return this.pt\n  }\n}\n","import Coordinate from '../geom/Coordinate.js'\nimport Double from '../../../../java/lang/Double.js'\nexport default class Intersection {\n  static intersection(p1, p2, q1, q2) {\n    const minX0 = p1.x < p2.x ? p1.x : p2.x\n    const minY0 = p1.y < p2.y ? p1.y : p2.y\n    const maxX0 = p1.x > p2.x ? p1.x : p2.x\n    const maxY0 = p1.y > p2.y ? p1.y : p2.y\n    const minX1 = q1.x < q2.x ? q1.x : q2.x\n    const minY1 = q1.y < q2.y ? q1.y : q2.y\n    const maxX1 = q1.x > q2.x ? q1.x : q2.x\n    const maxY1 = q1.y > q2.y ? q1.y : q2.y\n    const intMinX = minX0 > minX1 ? minX0 : minX1\n    const intMaxX = maxX0 < maxX1 ? maxX0 : maxX1\n    const intMinY = minY0 > minY1 ? minY0 : minY1\n    const intMaxY = maxY0 < maxY1 ? maxY0 : maxY1\n    const midx = (intMinX + intMaxX) / 2.0\n    const midy = (intMinY + intMaxY) / 2.0\n    const p1x = p1.x - midx\n    const p1y = p1.y - midy\n    const p2x = p2.x - midx\n    const p2y = p2.y - midy\n    const q1x = q1.x - midx\n    const q1y = q1.y - midy\n    const q2x = q2.x - midx\n    const q2y = q2.y - midy\n    const px = p1y - p2y\n    const py = p2x - p1x\n    const pw = p1x * p2y - p2x * p1y\n    const qx = q1y - q2y\n    const qy = q2x - q1x\n    const qw = q1x * q2y - q2x * q1y\n    const x = py * qw - qy * pw\n    const y = qx * pw - px * qw\n    const w = px * qy - qx * py\n    const xInt = x / w\n    const yInt = y / w\n    if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) \n      return null\n    \n    return new Coordinate(xInt + midx, yInt + midy)\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException.js'\nimport MathUtil from '../math/MathUtil.js'\nimport Envelope from '../geom/Envelope.js'\nexport default class Distance {\n  static pointToSegmentString(p, line) {\n    if (line.length === 0) throw new IllegalArgumentException('Line array must contain at least one vertex')\n    let minDistance = p.distance(line[0])\n    for (let i = 0; i < line.length - 1; i++) {\n      const dist = Distance.pointToSegment(p, line[i], line[i + 1])\n      if (dist < minDistance) \n        minDistance = dist\n      \n    }\n    return minDistance\n  }\n  static segmentToSegment(A, B, C, D) {\n    if (A.equals(B)) return Distance.pointToSegment(A, C, D)\n    if (C.equals(D)) return Distance.pointToSegment(D, A, B)\n    let noIntersection = false\n    if (!Envelope.intersects(A, B, C, D)) {\n      noIntersection = true\n    } else {\n      const denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x)\n      if (denom === 0) {\n        noIntersection = true\n      } else {\n        const r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y)\n        const s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y)\n        const s = s_num / denom\n        const r = r_num / denom\n        if (r < 0 || r > 1 || s < 0 || s > 1) \n          noIntersection = true\n        \n      }\n    }\n    if (noIntersection) \n      return MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B))\n    \n    return 0.0\n  }\n  static pointToLinePerpendicular(p, A, B) {\n    const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y)\n    const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2\n    return Math.abs(s) * Math.sqrt(len2)\n  }\n  static pointToSegment(p, A, B) {\n    if (A.x === B.x && A.y === B.y) return p.distance(A)\n    const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y)\n    const r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2\n    if (r <= 0.0) return p.distance(A)\n    if (r >= 1.0) return p.distance(B)\n    const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2\n    return Math.abs(s) * Math.sqrt(len2)\n  }\n}\n","import WKTWriter from '../io/WKTWriter.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Assert from '../util/Assert.js'\nimport StringBuilder from '../../../../java/lang/StringBuilder.js'\nexport default class LineIntersector {\n  constructor() {\n    LineIntersector.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._result = null\n    this._inputLines = Array(2).fill().map(() => Array(2))\n    this._intPt = new Array(2).fill(null)\n    this._intLineIndex = null\n    this._isProper = null\n    this._pa = null\n    this._pb = null\n    this._precisionModel = null\n    this._intPt[0] = new Coordinate()\n    this._intPt[1] = new Coordinate()\n    this._pa = this._intPt[0]\n    this._pb = this._intPt[1]\n    this._result = 0\n  }\n  static nonRobustComputeEdgeDistance(p, p1, p2) {\n    const dx = p.x - p1.x\n    const dy = p.y - p1.y\n    const dist = Math.sqrt(dx * dx + dy * dy)\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation')\n    return dist\n  }\n  static computeEdgeDistance(p, p0, p1) {\n    const dx = Math.abs(p1.x - p0.x)\n    const dy = Math.abs(p1.y - p0.y)\n    let dist = -1.0\n    if (p.equals(p0)) {\n      dist = 0.0\n    } else if (p.equals(p1)) {\n      if (dx > dy) dist = dx; else dist = dy\n    } else {\n      const pdx = Math.abs(p.x - p0.x)\n      const pdy = Math.abs(p.y - p0.y)\n      if (dx > dy) dist = pdx; else dist = pdy\n      if (dist === 0.0 && !p.equals(p0)) \n        dist = Math.max(pdx, pdy)\n      \n    }\n    Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation')\n    return dist\n  }\n  computeIntersection(p1, p2, p3, p4) {\n    this._inputLines[0][0] = p1\n    this._inputLines[0][1] = p2\n    this._inputLines[1][0] = p3\n    this._inputLines[1][1] = p4\n    this._result = this.computeIntersect(p1, p2, p3, p4)\n  }\n  getIntersectionNum() {\n    return this._result\n  }\n  computeIntLineIndex() {\n    if (arguments.length === 0) {\n      if (this._intLineIndex === null) {\n        this._intLineIndex = Array(2).fill().map(() => Array(2))\n        this.computeIntLineIndex(0)\n        this.computeIntLineIndex(1)\n      }\n    } else if (arguments.length === 1) {\n      const segmentIndex = arguments[0]\n      const dist0 = this.getEdgeDistance(segmentIndex, 0)\n      const dist1 = this.getEdgeDistance(segmentIndex, 1)\n      if (dist0 > dist1) {\n        this._intLineIndex[segmentIndex][0] = 0\n        this._intLineIndex[segmentIndex][1] = 1\n      } else {\n        this._intLineIndex[segmentIndex][0] = 1\n        this._intLineIndex[segmentIndex][1] = 0\n      }\n    }\n  }\n  isInteriorIntersection() {\n    if (arguments.length === 0) {\n      if (this.isInteriorIntersection(0)) return true\n      if (this.isInteriorIntersection(1)) return true\n      return false\n    } else if (arguments.length === 1) {\n      const inputLineIndex = arguments[0]\n      for (let i = 0; i < this._result; i++) \n        if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) \n          return true\n        \n      \n      return false\n    }\n  }\n  getIntersection(intIndex) {\n    return this._intPt[intIndex]\n  }\n  getEdgeDistance(segmentIndex, intIndex) {\n    const dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1])\n    return dist\n  }\n  isCollinear() {\n    return this._result === LineIntersector.COLLINEAR_INTERSECTION\n  }\n  toString() {\n    return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()\n  }\n  getEndpoint(segmentIndex, ptIndex) {\n    return this._inputLines[segmentIndex][ptIndex]\n  }\n  getIndexAlongSegment(segmentIndex, intIndex) {\n    this.computeIntLineIndex()\n    return this._intLineIndex[segmentIndex][intIndex]\n  }\n  getTopologySummary() {\n    const catBuilder = new StringBuilder()\n    if (this.isEndPoint()) catBuilder.append(' endpoint')\n    if (this._isProper) catBuilder.append(' proper')\n    if (this.isCollinear()) catBuilder.append(' collinear')\n    return catBuilder.toString()\n  }\n  isProper() {\n    return this.hasIntersection() && this._isProper\n  }\n  setPrecisionModel(precisionModel) {\n    this._precisionModel = precisionModel\n  }\n  isEndPoint() {\n    return this.hasIntersection() && !this._isProper\n  }\n  hasIntersection() {\n    return this._result !== LineIntersector.NO_INTERSECTION\n  }\n  isIntersection(pt) {\n    for (let i = 0; i < this._result; i++) \n      if (this._intPt[i].equals2D(pt)) \n        return true\n      \n    \n    return false\n  }\n  getIntersectionAlongSegment(segmentIndex, intIndex) {\n    this.computeIntLineIndex()\n    return this._intPt[this._intLineIndex[segmentIndex][intIndex]]\n  }\n}\nLineIntersector.DONT_INTERSECT = 0\nLineIntersector.DO_INTERSECT = 1\nLineIntersector.COLLINEAR = 2\nLineIntersector.NO_INTERSECTION = 0\nLineIntersector.POINT_INTERSECTION = 1\nLineIntersector.COLLINEAR_INTERSECTION = 2\n","import Coordinate from '../geom/Coordinate.js'\nimport Envelope from '../geom/Envelope.js'\nimport Orientation from './Orientation.js'\nimport Intersection from './Intersection.js'\nimport CGAlgorithmsDD from './CGAlgorithmsDD.js'\nimport System from '../../../../java/lang/System.js'\nimport Distance from './Distance.js'\nimport LineIntersector from './LineIntersector.js'\nexport default class RobustLineIntersector extends LineIntersector {\n  constructor() {\n    super()\n  }\n  static nearestEndpoint(p1, p2, q1, q2) {\n    let nearestPt = p1\n    let minDist = Distance.pointToSegment(p1, q1, q2)\n    let dist = Distance.pointToSegment(p2, q1, q2)\n    if (dist < minDist) {\n      minDist = dist\n      nearestPt = p2\n    }\n    dist = Distance.pointToSegment(q1, p1, p2)\n    if (dist < minDist) {\n      minDist = dist\n      nearestPt = q1\n    }\n    dist = Distance.pointToSegment(q2, p1, p2)\n    if (dist < minDist) {\n      minDist = dist\n      nearestPt = q2\n    }\n    return nearestPt\n  }\n  isInSegmentEnvelopes(intPt) {\n    const env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1])\n    const env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1])\n    return env0.contains(intPt) && env1.contains(intPt)\n  }\n  computeIntersection() {\n    if (arguments.length === 3) {\n      const p = arguments[0], p1 = arguments[1], p2 = arguments[2]\n      this._isProper = false\n      if (Envelope.intersects(p1, p2, p)) \n        if (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n          this._isProper = true\n          if (p.equals(p1) || p.equals(p2)) \n            this._isProper = false\n          \n          this._result = LineIntersector.POINT_INTERSECTION\n          return null\n        }\n      \n      this._result = LineIntersector.NO_INTERSECTION\n    } else {\n      return super.computeIntersection.apply(this, arguments)\n    }\n  }\n  intersection(p1, p2, q1, q2) {\n    let intPt = this.intersectionSafe(p1, p2, q1, q2)\n    if (!this.isInSegmentEnvelopes(intPt)) \n      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2))\n    \n    if (this._precisionModel !== null) \n      this._precisionModel.makePrecise(intPt)\n    \n    return intPt\n  }\n  checkDD(p1, p2, q1, q2, intPt) {\n    const intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2)\n    const isIn = this.isInSegmentEnvelopes(intPtDD)\n    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD)\n    if (intPt.distance(intPtDD) > 0.0001) \n      System.out.println('Distance = ' + intPt.distance(intPtDD))\n    \n  }\n  intersectionSafe(p1, p2, q1, q2) {\n    let intPt = Intersection.intersection(p1, p2, q1, q2)\n    if (intPt === null) intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2)\n    return intPt\n  }\n  computeCollinearIntersection(p1, p2, q1, q2) {\n    const p1q1p2 = Envelope.intersects(p1, p2, q1)\n    const p1q2p2 = Envelope.intersects(p1, p2, q2)\n    const q1p1q2 = Envelope.intersects(q1, q2, p1)\n    const q1p2q2 = Envelope.intersects(q1, q2, p2)\n    if (p1q1p2 && p1q2p2) {\n      this._intPt[0] = q1\n      this._intPt[1] = q2\n      return LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (q1p1q2 && q1p2q2) {\n      this._intPt[0] = p1\n      this._intPt[1] = p2\n      return LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p1q2) {\n      this._intPt[0] = q1\n      this._intPt[1] = p1\n      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p2q2) {\n      this._intPt[0] = q1\n      this._intPt[1] = p2\n      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p1q2) {\n      this._intPt[0] = q2\n      this._intPt[1] = p1\n      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p2q2) {\n      this._intPt[0] = q2\n      this._intPt[1] = p2\n      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION\n    }\n    return LineIntersector.NO_INTERSECTION\n  }\n  computeIntersect(p1, p2, q1, q2) {\n    this._isProper = false\n    if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION\n    const Pq1 = Orientation.index(p1, p2, q1)\n    const Pq2 = Orientation.index(p1, p2, q2)\n    if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) \n      return LineIntersector.NO_INTERSECTION\n    \n    const Qp1 = Orientation.index(q1, q2, p1)\n    const Qp2 = Orientation.index(q1, q2, p2)\n    if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) \n      return LineIntersector.NO_INTERSECTION\n    \n    const collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0\n    if (collinear) \n      return this.computeCollinearIntersection(p1, p2, q1, q2)\n    \n    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n      this._isProper = false\n      if (p1.equals2D(q1) || p1.equals2D(q2)) \n        this._intPt[0] = p1\n      else if (p2.equals2D(q1) || p2.equals2D(q2)) \n        this._intPt[0] = p2\n      else if (Pq1 === 0) \n        this._intPt[0] = new Coordinate(q1)\n      else if (Pq2 === 0) \n        this._intPt[0] = new Coordinate(q2)\n      else if (Qp1 === 0) \n        this._intPt[0] = new Coordinate(p1)\n      else if (Qp2 === 0) \n        this._intPt[0] = new Coordinate(p2)\n      \n    } else {\n      this._isProper = true\n      this._intPt[0] = this.intersection(p1, p2, q1, q2)\n    }\n    return LineIntersector.POINT_INTERSECTION\n  }\n}\n","import GeometryFactory from '../geom/GeometryFactory.js'\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector.js'\nimport RuntimeException from '../../../../java/lang/RuntimeException.js'\nexport default class NodingValidator {\n  constructor() {\n    NodingValidator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._li = new RobustLineIntersector()\n    this._segStrings = null\n    const segStrings = arguments[0]\n    this._segStrings = segStrings\n  }\n  checkEndPtVertexIntersections() {\n    if (arguments.length === 0) {\n      for (let i = this._segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        const pts = ss.getCoordinates()\n        this.checkEndPtVertexIntersections(pts[0], this._segStrings)\n        this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings)\n      }\n    } else if (arguments.length === 2) {\n      const testPt = arguments[0], segStrings = arguments[1]\n      for (let i = segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        const pts = ss.getCoordinates()\n        for (let j = 1; j < pts.length - 1; j++) \n          if (pts[j].equals(testPt)) throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt)\n        \n      }\n    }\n  }\n  checkInteriorIntersections() {\n    if (arguments.length === 0) {\n      for (let i = this._segStrings.iterator(); i.hasNext(); ) {\n        const ss0 = i.next()\n        for (let j = this._segStrings.iterator(); j.hasNext(); ) {\n          const ss1 = j.next()\n          this.checkInteriorIntersections(ss0, ss1)\n        }\n      }\n    } else if (arguments.length === 2) {\n      const ss0 = arguments[0], ss1 = arguments[1]\n      const pts0 = ss0.getCoordinates()\n      const pts1 = ss1.getCoordinates()\n      for (let i0 = 0; i0 < pts0.length - 1; i0++) \n        for (let i1 = 0; i1 < pts1.length - 1; i1++) \n          this.checkInteriorIntersections(ss0, i0, ss1, i1)\n        \n      \n    } else if (arguments.length === 4) {\n      const e0 = arguments[0], segIndex0 = arguments[1], e1 = arguments[2], segIndex1 = arguments[3]\n      if (e0 === e1 && segIndex0 === segIndex1) return null\n      const p00 = e0.getCoordinates()[segIndex0]\n      const p01 = e0.getCoordinates()[segIndex0 + 1]\n      const p10 = e1.getCoordinates()[segIndex1]\n      const p11 = e1.getCoordinates()[segIndex1 + 1]\n      this._li.computeIntersection(p00, p01, p10, p11)\n      if (this._li.hasIntersection()) \n        if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) \n          throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)\n        \n      \n    }\n  }\n  checkValid() {\n    this.checkEndPtVertexIntersections()\n    this.checkInteriorIntersections()\n    this.checkCollapses()\n  }\n  checkCollapses() {\n    if (arguments.length === 0) {\n      for (let i = this._segStrings.iterator(); i.hasNext(); ) {\n        const ss = i.next()\n        this.checkCollapses(ss)\n      }\n    } else if (arguments.length === 1) {\n      const ss = arguments[0]\n      const pts = ss.getCoordinates()\n      for (let i = 0; i < pts.length - 2; i++) \n        this.checkCollapse(pts[i], pts[i + 1], pts[i + 2])\n      \n    }\n  }\n  hasInteriorIntersection(li, p0, p1) {\n    for (let i = 0; i < li.getIntersectionNum(); i++) {\n      const intPt = li.getIntersection(i)\n      if (!(intPt.equals(p0) || intPt.equals(p1))) return true\n    }\n    return false\n  }\n  checkCollapse(p0, p1, p2) {\n    if (p0.equals(p2)) throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2]))\n  }\n}\nNodingValidator.fact = new GeometryFactory()\n","export default class Boundable {\n  getBounds() {}\n}\n","import Boundable from './Boundable.js'\nimport Serializable from '../../../../../java/io/Serializable.js'\nexport default class ItemBoundable {\n  constructor() {\n    ItemBoundable.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._bounds = null\n    this._item = null\n    const bounds = arguments[0], item = arguments[1]\n    this._bounds = bounds\n    this._item = item\n  }\n  getItem() {\n    return this._item\n  }\n  getBounds() {\n    return this._bounds\n  }\n  get interfaces_() {\n    return [Boundable, Serializable]\n  }\n}\n","import FastPriorityQueue from 'fastpriorityqueue'\n\nexport default class PriorityQueue {\n\n  constructor() {\n    this._fpQueue = new FastPriorityQueue((a,b) => a.compareTo(b) < 0)\n  }\n\n  poll() {\n    return this._fpQueue.poll()\n  }\n  size() {\n    return this._fpQueue.size\n  }\n  clear() {\n    this._fpQueue = new FastPriorityQueue()\n  }\n  peek() {\n    return this._fpQueue.peek()\n  }\n  remove() {\n    return this._fpQueue.poll()\n  }\n  isEmpty() {\n    return this._fpQueue.isEmpty()\n  }\n  add(x) {\n    this._fpQueue.add(x)\n  }\n}\n","export default class SpatialIndex {\n  query() {\n    if (arguments.length === 1) {\n      const searchEnv = arguments[0]\n    } else if (arguments.length === 2) {\n      const searchEnv = arguments[0], visitor = arguments[1]\n    }\n  }\n  insert(itemEnv, item) {}\n  remove(itemEnv, item) {}\n}\n","import Boundable from './Boundable.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Serializable from '../../../../../java/io/Serializable.js'\nimport Assert from '../../util/Assert.js'\nexport default class AbstractNode {\n  constructor() {\n    AbstractNode.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._childBoundables = new ArrayList()\n    this._bounds = null\n    this._level = null\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const level = arguments[0]\n      this._level = level\n    }\n  }\n  getLevel() {\n    return this._level\n  }\n  addChildBoundable(childBoundable) {\n    Assert.isTrue(this._bounds === null)\n    this._childBoundables.add(childBoundable)\n  }\n  isEmpty() {\n    return this._childBoundables.isEmpty()\n  }\n  getBounds() {\n    if (this._bounds === null) \n      this._bounds = this.computeBounds()\n    \n    return this._bounds\n  }\n  size() {\n    return this._childBoundables.size()\n  }\n  getChildBoundables() {\n    return this._childBoundables\n  }\n  get interfaces_() {\n    return [Boundable, Serializable]\n  }\n}\n","import Arrays from './Arrays.js'\nimport ArrayList from './ArrayList.js'\n\nconst Collections = {\n  reverseOrder: function() {\n    return {\n      compare(a, b) {\n        return b.compareTo(a)\n      }\n    }\n  },\n  min: function(l) {\n    Collections.sort(l)\n    return l.get(0)\n  },\n  sort: function(l, c) {\n    const a = l.toArray()\n    if (c)\n      Arrays.sort(a, c)\n    else\n      Arrays.sort(a)\n    const i = l.iterator()\n    for (let pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next()\n      i.set(a[pos])\n    }\n  },\n  singletonList: function(o) {\n    const arrayList = new ArrayList()\n    arrayList.add(o)\n    return arrayList\n  }\n}\n\nexport default Collections\n","export default class EnvelopeDistance {\n  static distance(x1, y1, x2, y2) {\n    const dx = x2 - x1\n    const dy = y2 - y1\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n  static maximumDistance(env1, env2) {\n    const minx = Math.min(env1.getMinX(), env2.getMinX())\n    const miny = Math.min(env1.getMinY(), env2.getMinY())\n    const maxx = Math.max(env1.getMaxX(), env2.getMaxX())\n    const maxy = Math.max(env1.getMaxY(), env2.getMaxY())\n    return EnvelopeDistance.distance(minx, miny, maxx, maxy)\n  }\n  static minMaxDistance(a, b) {\n    const aminx = a.getMinX()\n    const aminy = a.getMinY()\n    const amaxx = a.getMaxX()\n    const amaxy = a.getMaxY()\n    const bminx = b.getMinX()\n    const bminy = b.getMinY()\n    const bmaxx = b.getMaxX()\n    const bmaxy = b.getMaxY()\n    let dist = EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bminx, bmaxy)\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bmaxx, bminy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy))\n    dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy))\n    return dist\n  }\n  static maxDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n    let dist = EnvelopeDistance.distance(ax1, ay1, bx1, by1)\n    dist = Math.max(dist, EnvelopeDistance.distance(ax1, ay1, bx2, by2))\n    dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx1, by1))\n    dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx2, by2))\n    return dist\n  }\n}\n","import IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException.js'\nimport AbstractNode from './AbstractNode.js'\nimport EnvelopeDistance from './EnvelopeDistance.js'\nimport Comparable from '../../../../../java/lang/Comparable.js'\nexport default class BoundablePair {\n  constructor() {\n    BoundablePair.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._boundable1 = null\n    this._boundable2 = null\n    this._distance = null\n    this._itemDistance = null\n    const boundable1 = arguments[0], boundable2 = arguments[1], itemDistance = arguments[2]\n    this._boundable1 = boundable1\n    this._boundable2 = boundable2\n    this._itemDistance = itemDistance\n    this._distance = this.distance()\n  }\n  static area(b) {\n    return b.getBounds().getArea()\n  }\n  static isComposite(item) {\n    return item instanceof AbstractNode\n  }\n  maximumDistance() {\n    return EnvelopeDistance.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds())\n  }\n  expandToQueue(priQ, minDistance) {\n    const isComp1 = BoundablePair.isComposite(this._boundable1)\n    const isComp2 = BoundablePair.isComposite(this._boundable2)\n    if (isComp1 && isComp2) {\n      if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n        this.expand(this._boundable1, this._boundable2, false, priQ, minDistance)\n        return null\n      } else {\n        this.expand(this._boundable2, this._boundable1, true, priQ, minDistance)\n        return null\n      }\n    } else if (isComp1) {\n      this.expand(this._boundable1, this._boundable2, false, priQ, minDistance)\n      return null\n    } else if (isComp2) {\n      this.expand(this._boundable2, this._boundable1, true, priQ, minDistance)\n      return null\n    }\n    throw new IllegalArgumentException('neither boundable is composite')\n  }\n  isLeaves() {\n    return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))\n  }\n  getBoundable(i) {\n    if (i === 0) return this._boundable1\n    return this._boundable2\n  }\n  getDistance() {\n    return this._distance\n  }\n  distance() {\n    if (this.isLeaves()) \n      return this._itemDistance.distance(this._boundable1, this._boundable2)\n    \n    return this._boundable1.getBounds().distance(this._boundable2.getBounds())\n  }\n  compareTo(o) {\n    const nd = o\n    if (this._distance < nd._distance) return -1\n    if (this._distance > nd._distance) return 1\n    return 0\n  }\n  expand(bndComposite, bndOther, isFlipped, priQ, minDistance) {\n    const children = bndComposite.getChildBoundables()\n    for (let i = children.iterator(); i.hasNext(); ) {\n      const child = i.next()\n      let bp = null\n      if (isFlipped) \n        bp = new BoundablePair(bndOther, child, this._itemDistance)\n      else \n        bp = new BoundablePair(child, bndOther, this._itemDistance)\n      \n      if (bp.getDistance() < minDistance) \n        priQ.add(bp)\n      \n    }\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","export default class ItemVisitor {\n  visitItem(item) {}\n}\n","import ItemBoundable from './ItemBoundable.js'\nimport hasInterface from '../../../../../hasInterface.js'\nimport ItemVisitor from '../ItemVisitor.js'\nimport AbstractNode from './AbstractNode.js'\nimport Collections from '../../../../../java/util/Collections.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Serializable from '../../../../../java/io/Serializable.js'\nimport Assert from '../../util/Assert.js'\nimport List from '../../../../../java/util/List.js'\nexport default class AbstractSTRtree {\n  constructor() {\n    AbstractSTRtree.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._root = null\n    this._built = false\n    this._itemBoundables = new ArrayList()\n    this._nodeCapacity = null\n    if (arguments.length === 0) {\n      AbstractSTRtree.constructor_.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY)\n    } else if (arguments.length === 1) {\n      const nodeCapacity = arguments[0]\n      Assert.isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1')\n      this._nodeCapacity = nodeCapacity\n    }\n  }\n  static compareDoubles(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0\n  }\n  queryInternal() {\n    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      const searchBounds = arguments[0], node = arguments[1], visitor = arguments[2]\n      const childBoundables = node.getChildBoundables()\n      for (let i = 0; i < childBoundables.size(); i++) {\n        const childBoundable = childBoundables.get(i)\n        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) \n          continue\n        \n        if (childBoundable instanceof AbstractNode) \n          this.queryInternal(searchBounds, childBoundable, visitor)\n        else if (childBoundable instanceof ItemBoundable) \n          visitor.visitItem(childBoundable.getItem())\n        else \n          Assert.shouldNeverReachHere()\n        \n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      const searchBounds = arguments[0], node = arguments[1], matches = arguments[2]\n      const childBoundables = node.getChildBoundables()\n      for (let i = 0; i < childBoundables.size(); i++) {\n        const childBoundable = childBoundables.get(i)\n        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) \n          continue\n        \n        if (childBoundable instanceof AbstractNode) \n          this.queryInternal(searchBounds, childBoundable, matches)\n        else if (childBoundable instanceof ItemBoundable) \n          matches.add(childBoundable.getItem())\n        else \n          Assert.shouldNeverReachHere()\n        \n      }\n    }\n  }\n  insert(bounds, item) {\n    Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.')\n    this._itemBoundables.add(new ItemBoundable(bounds, item))\n  }\n  boundablesAtLevel() {\n    if (arguments.length === 1) {\n      const level = arguments[0]\n      const boundables = new ArrayList()\n      this.boundablesAtLevel(level, this._root, boundables)\n      return boundables\n    } else if (arguments.length === 3) {\n      const level = arguments[0], top = arguments[1], boundables = arguments[2]\n      Assert.isTrue(level > -2)\n      if (top.getLevel() === level) {\n        boundables.add(top)\n        return null\n      }\n      for (let i = top.getChildBoundables().iterator(); i.hasNext(); ) {\n        const boundable = i.next()\n        if (boundable instanceof AbstractNode) {\n          this.boundablesAtLevel(level, boundable, boundables)\n        } else {\n          Assert.isTrue(boundable instanceof ItemBoundable)\n          if (level === -1) \n            boundables.add(boundable)\n          \n        }\n      }\n      return null\n    }\n  }\n  getRoot() {\n    this.build()\n    return this._root\n  }\n  remove() {\n    if (arguments.length === 2) {\n      const searchBounds = arguments[0], item = arguments[1]\n      this.build()\n      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) \n        return this.remove(searchBounds, this._root, item)\n      \n      return false\n    } else if (arguments.length === 3) {\n      const searchBounds = arguments[0], node = arguments[1], item = arguments[2]\n      let found = this.removeItem(node, item)\n      if (found) return true\n      let childToPrune = null\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) \n          continue\n        \n        if (childBoundable instanceof AbstractNode) {\n          found = this.remove(searchBounds, childBoundable, item)\n          if (found) {\n            childToPrune = childBoundable\n            break\n          }\n        }\n      }\n      if (childToPrune !== null) \n        if (childToPrune.getChildBoundables().isEmpty()) \n          node.getChildBoundables().remove(childToPrune)\n        \n      \n      return found\n    }\n  }\n  createHigherLevels(boundablesOfALevel, level) {\n    Assert.isTrue(!boundablesOfALevel.isEmpty())\n    const parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1)\n    if (parentBoundables.size() === 1) \n      return parentBoundables.get(0)\n    \n    return this.createHigherLevels(parentBoundables, level + 1)\n  }\n  depth() {\n    if (arguments.length === 0) {\n      if (this.isEmpty()) \n        return 0\n      \n      this.build()\n      return this.depth(this._root)\n    } else if (arguments.length === 1) {\n      const node = arguments[0]\n      let maxChildDepth = 0\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (childBoundable instanceof AbstractNode) {\n          const childDepth = this.depth(childBoundable)\n          if (childDepth > maxChildDepth) maxChildDepth = childDepth\n        }\n      }\n      return maxChildDepth + 1\n    }\n  }\n  createParentBoundables(childBoundables, newLevel) {\n    Assert.isTrue(!childBoundables.isEmpty())\n    const parentBoundables = new ArrayList()\n    parentBoundables.add(this.createNode(newLevel))\n    const sortedChildBoundables = new ArrayList(childBoundables)\n    Collections.sort(sortedChildBoundables, this.getComparator())\n    for (let i = sortedChildBoundables.iterator(); i.hasNext(); ) {\n      const childBoundable = i.next()\n      if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) \n        parentBoundables.add(this.createNode(newLevel))\n      \n      this.lastNode(parentBoundables).addChildBoundable(childBoundable)\n    }\n    return parentBoundables\n  }\n  isEmpty() {\n    if (!this._built) return this._itemBoundables.isEmpty()\n    return this._root.isEmpty()\n  }\n  getNodeCapacity() {\n    return this._nodeCapacity\n  }\n  lastNode(nodes) {\n    return nodes.get(nodes.size() - 1)\n  }\n  size() {\n    if (arguments.length === 0) {\n      if (this.isEmpty()) \n        return 0\n      \n      this.build()\n      return this.size(this._root)\n    } else if (arguments.length === 1) {\n      const node = arguments[0]\n      let size = 0\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (childBoundable instanceof AbstractNode) \n          size += this.size(childBoundable)\n        else if (childBoundable instanceof ItemBoundable) \n          size += 1\n        \n      }\n      return size\n    }\n  }\n  removeItem(node, item) {\n    let childToRemove = null\n    for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n      const childBoundable = i.next()\n      if (childBoundable instanceof ItemBoundable) \n        if (childBoundable.getItem() === item) childToRemove = childBoundable\n      \n    }\n    if (childToRemove !== null) {\n      node.getChildBoundables().remove(childToRemove)\n      return true\n    }\n    return false\n  }\n  itemsTree() {\n    if (arguments.length === 0) {\n      this.build()\n      const valuesTree = this.itemsTree(this._root)\n      if (valuesTree === null) return new ArrayList()\n      return valuesTree\n    } else if (arguments.length === 1) {\n      const node = arguments[0]\n      const valuesTreeForNode = new ArrayList()\n      for (let i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n        const childBoundable = i.next()\n        if (childBoundable instanceof AbstractNode) {\n          const valuesTreeForChild = this.itemsTree(childBoundable)\n          if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild)\n        } else if (childBoundable instanceof ItemBoundable) {\n          valuesTreeForNode.add(childBoundable.getItem())\n        } else {\n          Assert.shouldNeverReachHere()\n        }\n      }\n      if (valuesTreeForNode.size() <= 0) return null\n      return valuesTreeForNode\n    }\n  }\n  query() {\n    if (arguments.length === 1) {\n      const searchBounds = arguments[0]\n      this.build()\n      const matches = new ArrayList()\n      if (this.isEmpty()) \n        return matches\n      \n      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) \n        this.queryInternal(searchBounds, this._root, matches)\n      \n      return matches\n    } else if (arguments.length === 2) {\n      const searchBounds = arguments[0], visitor = arguments[1]\n      this.build()\n      if (this.isEmpty()) \n        return null\n      \n      if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) \n        this.queryInternal(searchBounds, this._root, visitor)\n      \n    }\n  }\n  build() {\n    if (this._built) return null\n    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1)\n    this._itemBoundables = null\n    this._built = true\n  }\n  get interfaces_() {\n    return [Serializable]\n  }\n}\nfunction IntersectsOp() {}\nAbstractSTRtree.IntersectsOp = IntersectsOp\nAbstractSTRtree.DEFAULT_NODE_CAPACITY = 10\n","export default class ItemDistance {\n  distance(item1, item2) {}\n}\n","import ItemBoundable from './ItemBoundable.js'\nimport PriorityQueue from '../../../../../java/util/PriorityQueue.js'\nimport hasInterface from '../../../../../hasInterface.js'\nimport Double from '../../../../../java/lang/Double.js'\nimport Serializable from '../../../../../java/io/Serializable.js'\nimport SpatialIndex from '../SpatialIndex.js'\nimport AbstractNode from './AbstractNode.js'\nimport Collections from '../../../../../java/util/Collections.js'\nimport BoundablePair from './BoundablePair.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Comparator from '../../../../../java/util/Comparator.js'\nimport Envelope from '../../geom/Envelope.js'\nimport Assert from '../../util/Assert.js'\nimport AbstractSTRtree from './AbstractSTRtree.js'\nimport ItemDistance from './ItemDistance.js'\nexport default class STRtree extends AbstractSTRtree {\n  constructor() {\n    super()\n    STRtree.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    if (arguments.length === 0) {\n      STRtree.constructor_.call(this, STRtree.DEFAULT_NODE_CAPACITY)\n    } else if (arguments.length === 1) {\n      const nodeCapacity = arguments[0]\n      AbstractSTRtree.constructor_.call(this, nodeCapacity)\n    }\n  }\n  static getItems(kNearestNeighbors) {\n    const items = new Array(kNearestNeighbors.size()).fill(null)\n    let count = 0\n    while (!kNearestNeighbors.isEmpty()) {\n      const bp = kNearestNeighbors.poll()\n      items[count] = bp.getBoundable(0).getItem()\n      count++\n    }\n    return items\n  }\n  static avg(a, b) {\n    return (a + b) / 2\n  }\n  static centreY(e) {\n    return STRtree.avg(e.getMinY(), e.getMaxY())\n  }\n  static centreX(e) {\n    return STRtree.avg(e.getMinX(), e.getMaxX())\n  }\n  size() {\n    if (arguments.length === 0) \n      return super.size.call(this)\n    else return super.size.apply(this, arguments)\n  }\n  insert() {\n    if (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {\n      const itemEnv = arguments[0], item = arguments[1]\n      if (itemEnv.isNull()) \n        return null\n      \n      super.insert.call(this, itemEnv, item)\n    } else {\n      return super.insert.apply(this, arguments)\n    }\n  }\n  getIntersectsOp() {\n    return STRtree.intersectsOp\n  }\n  verticalSlices(childBoundables, sliceCount) {\n    const sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount))\n    const slices = new Array(sliceCount).fill(null)\n    const i = childBoundables.iterator()\n    for (let j = 0; j < sliceCount; j++) {\n      slices[j] = new ArrayList()\n      let boundablesAddedToSlice = 0\n      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n        const childBoundable = i.next()\n        slices[j].add(childBoundable)\n        boundablesAddedToSlice++\n      }\n    }\n    return slices\n  }\n  query() {\n    if (arguments.length === 1) {\n      const searchEnv = arguments[0]\n      return super.query.call(this, searchEnv)\n    } else if (arguments.length === 2) {\n      const searchEnv = arguments[0], visitor = arguments[1]\n      super.query.call(this, searchEnv, visitor)\n    }\n  }\n  getComparator() {\n    return STRtree.yComparator\n  }\n  createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n    return super.createParentBoundables.call(this, childBoundables, newLevel)\n  }\n  remove() {\n    if (arguments.length === 2 && (arguments[1] instanceof Object && arguments[0] instanceof Envelope)) {\n      const itemEnv = arguments[0], item = arguments[1]\n      return super.remove.call(this, itemEnv, item)\n    } else {\n      return super.remove.apply(this, arguments)\n    }\n  }\n  depth() {\n    if (arguments.length === 0) \n      return super.depth.call(this)\n    else return super.depth.apply(this, arguments)\n  }\n  createParentBoundables(childBoundables, newLevel) {\n    Assert.isTrue(!childBoundables.isEmpty())\n    const minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()))\n    const sortedChildBoundables = new ArrayList(childBoundables)\n    Collections.sort(sortedChildBoundables, STRtree.xComparator)\n    const verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))))\n    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)\n  }\n  nearestNeighbour() {\n    if (arguments.length === 1) {\n      if (hasInterface(arguments[0], ItemDistance)) {\n        const itemDist = arguments[0]\n        if (this.isEmpty()) return null\n        const bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist)\n        return this.nearestNeighbour(bp)\n      } else if (arguments[0] instanceof BoundablePair) {\n        const initBndPair = arguments[0]\n        let distanceLowerBound = Double.POSITIVE_INFINITY\n        let minPair = null\n        const priQ = new PriorityQueue()\n        priQ.add(initBndPair)\n        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n          const bndPair = priQ.poll()\n          const pairDistance = bndPair.getDistance()\n          if (pairDistance >= distanceLowerBound) break\n          if (bndPair.isLeaves()) {\n            distanceLowerBound = pairDistance\n            minPair = bndPair\n          } else {\n            bndPair.expandToQueue(priQ, distanceLowerBound)\n          }\n        }\n        if (minPair === null) return null\n        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]\n      }\n    } else if (arguments.length === 2) {\n      const tree = arguments[0], itemDist = arguments[1]\n      if (this.isEmpty() || tree.isEmpty()) return null\n      const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist)\n      return this.nearestNeighbour(bp)\n    } else if (arguments.length === 3) {\n      const env = arguments[0], item = arguments[1], itemDist = arguments[2]\n      const bnd = new ItemBoundable(env, item)\n      const bp = new BoundablePair(this.getRoot(), bnd, itemDist)\n      return this.nearestNeighbour(bp)[0]\n    } else if (arguments.length === 4) {\n      const env = arguments[0], item = arguments[1], itemDist = arguments[2], k = arguments[3]\n      const bnd = new ItemBoundable(env, item)\n      const bp = new BoundablePair(this.getRoot(), bnd, itemDist)\n      return this.nearestNeighbourK(bp, k)\n    }\n  }\n  isWithinDistance() {\n    if (arguments.length === 2) {\n      const initBndPair = arguments[0], maxDistance = arguments[1]\n      let distanceUpperBound = Double.POSITIVE_INFINITY\n      const priQ = new PriorityQueue()\n      priQ.add(initBndPair)\n      while (!priQ.isEmpty()) {\n        const bndPair = priQ.poll()\n        const pairDistance = bndPair.getDistance()\n        if (pairDistance > maxDistance) return false\n        if (bndPair.maximumDistance() <= maxDistance) return true\n        if (bndPair.isLeaves()) {\n          distanceUpperBound = pairDistance\n          if (distanceUpperBound <= maxDistance) return true\n        } else {\n          bndPair.expandToQueue(priQ, distanceUpperBound)\n        }\n      }\n      return false\n    } else if (arguments.length === 3) {\n      const tree = arguments[0], itemDist = arguments[1], maxDistance = arguments[2]\n      const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist)\n      return this.isWithinDistance(bp, maxDistance)\n    }\n  }\n  createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n    Assert.isTrue(verticalSlices.length > 0)\n    const parentBoundables = new ArrayList()\n    for (let i = 0; i < verticalSlices.length; i++) \n      parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel))\n    \n    return parentBoundables\n  }\n  nearestNeighbourK() {\n    if (arguments.length === 2) {\n      const initBndPair = arguments[0], k = arguments[1]\n      return this.nearestNeighbourK(initBndPair, Double.POSITIVE_INFINITY, k)\n    } else if (arguments.length === 3) {\n      const initBndPair = arguments[0], maxDistance = arguments[1], k = arguments[2]\n      let distanceLowerBound = maxDistance\n      const priQ = new PriorityQueue()\n      priQ.add(initBndPair)\n      const kNearestNeighbors = new PriorityQueue()\n      while (!priQ.isEmpty() && distanceLowerBound >= 0.0) {\n        const bndPair = priQ.poll()\n        const pairDistance = bndPair.getDistance()\n        if (pairDistance >= distanceLowerBound) \n          break\n        \n        if (bndPair.isLeaves()) \n          if (kNearestNeighbors.size() < k) {\n            kNearestNeighbors.add(bndPair)\n          } else {\n            const bp1 = kNearestNeighbors.peek()\n            if (bp1.getDistance() > pairDistance) {\n              kNearestNeighbors.poll()\n              kNearestNeighbors.add(bndPair)\n            }\n            const bp2 = kNearestNeighbors.peek()\n            distanceLowerBound = bp2.getDistance()\n          }\n        else \n          bndPair.expandToQueue(priQ, distanceLowerBound)\n        \n      }\n      return STRtree.getItems(kNearestNeighbors)\n    }\n  }\n  createNode(level) {\n    return new STRtreeNode(level)\n  }\n  get interfaces_() {\n    return [SpatialIndex, Serializable]\n  }\n}\nclass STRtreeNode extends AbstractNode {\n  constructor() {\n    super()\n    STRtreeNode.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const level = arguments[0]\n    AbstractNode.constructor_.call(this, level)\n  }\n  computeBounds() {\n    let bounds = null\n    for (let i = this.getChildBoundables().iterator(); i.hasNext(); ) {\n      const childBoundable = i.next()\n      if (bounds === null) \n        bounds = new Envelope(childBoundable.getBounds())\n      else \n        bounds.expandToInclude(childBoundable.getBounds())\n      \n    }\n    return bounds\n  }\n}\nSTRtree.STRtreeNode = STRtreeNode\nSTRtree.xComparator = new (class {\n  get interfaces_() {\n    return [Comparator]\n  }\n  compare(o1, o2) {\n    return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))\n  }\n})()\nSTRtree.yComparator = new (class {\n  get interfaces_() {\n    return [Comparator]\n  }\n  compare(o1, o2) {\n    return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))\n  }\n})()\nSTRtree.intersectsOp = new (class {\n  get interfaces_() {\n    return [IntersectsOp]\n  }\n  intersects(aBounds, bBounds) {\n    return aBounds.intersects(bBounds)\n  }\n})()\nSTRtree.DEFAULT_NODE_CAPACITY = 10\n","import Coordinate from './Coordinate.js'\nimport Double from '../../../../java/lang/Double.js'\nimport Comparable from '../../../../java/lang/Comparable.js'\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector.js'\nimport Serializable from '../../../../java/io/Serializable.js'\nimport IllegalStateException from '../../../../java/lang/IllegalStateException.js'\nimport Distance from '../algorithm/Distance.js'\nimport Orientation from '../algorithm/Orientation.js'\nimport Intersection from '../algorithm/Intersection.js'\nexport default class LineSegment {\n  constructor() {\n    LineSegment.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.p0 = null\n    this.p1 = null\n    if (arguments.length === 0) {\n      LineSegment.constructor_.call(this, new Coordinate(), new Coordinate())\n    } else if (arguments.length === 1) {\n      const ls = arguments[0]\n      LineSegment.constructor_.call(this, ls.p0, ls.p1)\n    } else if (arguments.length === 2) {\n      const p0 = arguments[0], p1 = arguments[1]\n      this.p0 = p0\n      this.p1 = p1\n    } else if (arguments.length === 4) {\n      const x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3]\n      LineSegment.constructor_.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1))\n    }\n  }\n  static midPoint(p0, p1) {\n    return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)\n  }\n  minX() {\n    return Math.min(this.p0.x, this.p1.x)\n  }\n  orientationIndex() {\n    if (arguments[0] instanceof LineSegment) {\n      const seg = arguments[0]\n      const orient0 = Orientation.index(this.p0, this.p1, seg.p0)\n      const orient1 = Orientation.index(this.p0, this.p1, seg.p1)\n      if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1)\n      if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1)\n      return 0\n    } else if (arguments[0] instanceof Coordinate) {\n      const p = arguments[0]\n      return Orientation.index(this.p0, this.p1, p)\n    }\n  }\n  toGeometry(geomFactory) {\n    return geomFactory.createLineString([this.p0, this.p1])\n  }\n  isVertical() {\n    return this.p0.x === this.p1.x\n  }\n  minY() {\n    return Math.min(this.p0.y, this.p1.y)\n  }\n  midPoint() {\n    return LineSegment.midPoint(this.p0, this.p1)\n  }\n  maxY() {\n    return Math.max(this.p0.y, this.p1.y)\n  }\n  pointAlongOffset(segmentLengthFraction, offsetDistance) {\n    const segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x)\n    const segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y)\n    const dx = this.p1.x - this.p0.x\n    const dy = this.p1.y - this.p0.y\n    const len = Math.sqrt(dx * dx + dy * dy)\n    let ux = 0.0\n    let uy = 0.0\n    if (offsetDistance !== 0.0) {\n      if (len <= 0.0) throw new IllegalStateException('Cannot compute offset from zero-length line segment')\n      ux = offsetDistance * dx / len\n      uy = offsetDistance * dy / len\n    }\n    const offsetx = segx - uy\n    const offsety = segy + ux\n    const coord = new Coordinate(offsetx, offsety)\n    return coord\n  }\n  setCoordinates() {\n    if (arguments.length === 1) {\n      const ls = arguments[0]\n      this.setCoordinates(ls.p0, ls.p1)\n    } else if (arguments.length === 2) {\n      const p0 = arguments[0], p1 = arguments[1]\n      this.p0.x = p0.x\n      this.p0.y = p0.y\n      this.p1.x = p1.x\n      this.p1.y = p1.y\n    }\n  }\n  segmentFraction(inputPt) {\n    let segFrac = this.projectionFactor(inputPt)\n    if (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0\n    return segFrac\n  }\n  toString() {\n    return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'\n  }\n  distance() {\n    if (arguments[0] instanceof LineSegment) {\n      const ls = arguments[0]\n      return Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1)\n    } else if (arguments[0] instanceof Coordinate) {\n      const p = arguments[0]\n      return Distance.pointToSegment(p, this.p0, this.p1)\n    }\n  }\n  equals(o) {\n    if (!(o instanceof LineSegment)) \n      return false\n    \n    const other = o\n    return this.p0.equals(other.p0) && this.p1.equals(other.p1)\n  }\n  intersection(line) {\n    const li = new RobustLineIntersector()\n    li.computeIntersection(this.p0, this.p1, line.p0, line.p1)\n    if (li.hasIntersection()) return li.getIntersection(0)\n    return null\n  }\n  project() {\n    if (arguments[0] instanceof Coordinate) {\n      const p = arguments[0]\n      if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p)\n      const r = this.projectionFactor(p)\n      const coord = new Coordinate()\n      coord.x = this.p0.x + r * (this.p1.x - this.p0.x)\n      coord.y = this.p0.y + r * (this.p1.y - this.p0.y)\n      return coord\n    } else if (arguments[0] instanceof LineSegment) {\n      const seg = arguments[0]\n      const pf0 = this.projectionFactor(seg.p0)\n      const pf1 = this.projectionFactor(seg.p1)\n      if (pf0 >= 1.0 && pf1 >= 1.0) return null\n      if (pf0 <= 0.0 && pf1 <= 0.0) return null\n      let newp0 = this.project(seg.p0)\n      if (pf0 < 0.0) newp0 = this.p0\n      if (pf0 > 1.0) newp0 = this.p1\n      let newp1 = this.project(seg.p1)\n      if (pf1 < 0.0) newp1 = this.p0\n      if (pf1 > 1.0) newp1 = this.p1\n      return new LineSegment(newp0, newp1)\n    }\n  }\n  normalize() {\n    if (this.p1.compareTo(this.p0) < 0) this.reverse()\n  }\n  angle() {\n    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)\n  }\n  getCoordinate(i) {\n    if (i === 0) return this.p0\n    return this.p1\n  }\n  distancePerpendicular(p) {\n    return Distance.pointToLinePerpendicular(p, this.p0, this.p1)\n  }\n  closestPoint(p) {\n    const factor = this.projectionFactor(p)\n    if (factor > 0 && factor < 1) \n      return this.project(p)\n    \n    const dist0 = this.p0.distance(p)\n    const dist1 = this.p1.distance(p)\n    if (dist0 < dist1) return this.p0\n    return this.p1\n  }\n  projectionFactor(p) {\n    if (p.equals(this.p0)) return 0.0\n    if (p.equals(this.p1)) return 1.0\n    const dx = this.p1.x - this.p0.x\n    const dy = this.p1.y - this.p0.y\n    const len = dx * dx + dy * dy\n    if (len <= 0.0) return Double.NaN\n    const r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len\n    return r\n  }\n  closestPoints(line) {\n    const intPt = this.intersection(line)\n    if (intPt !== null) \n      return [intPt, intPt]\n    \n    const closestPt = new Array(2).fill(null)\n    let minDistance = Double.MAX_VALUE\n    let dist = null\n    const close00 = this.closestPoint(line.p0)\n    minDistance = close00.distance(line.p0)\n    closestPt[0] = close00\n    closestPt[1] = line.p0\n    const close01 = this.closestPoint(line.p1)\n    dist = close01.distance(line.p1)\n    if (dist < minDistance) {\n      minDistance = dist\n      closestPt[0] = close01\n      closestPt[1] = line.p1\n    }\n    const close10 = line.closestPoint(this.p0)\n    dist = close10.distance(this.p0)\n    if (dist < minDistance) {\n      minDistance = dist\n      closestPt[0] = this.p0\n      closestPt[1] = close10\n    }\n    const close11 = line.closestPoint(this.p1)\n    dist = close11.distance(this.p1)\n    if (dist < minDistance) {\n      minDistance = dist\n      closestPt[0] = this.p1\n      closestPt[1] = close11\n    }\n    return closestPt\n  }\n  maxX() {\n    return Math.max(this.p0.x, this.p1.x)\n  }\n  getLength() {\n    return this.p0.distance(this.p1)\n  }\n  compareTo(o) {\n    const other = o\n    const comp0 = this.p0.compareTo(other.p0)\n    if (comp0 !== 0) return comp0\n    return this.p1.compareTo(other.p1)\n  }\n  reverse() {\n    const temp = this.p0\n    this.p0 = this.p1\n    this.p1 = temp\n  }\n  equalsTopo(other) {\n    return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0)\n  }\n  lineIntersection(line) {\n    const intPt = Intersection.intersection(this.p0, this.p1, line.p0, line.p1)\n    return intPt\n  }\n  isHorizontal() {\n    return this.p0.y === this.p1.y\n  }\n  reflect(p) {\n    const A = this.p1.getY() - this.p0.getY()\n    const B = this.p0.getX() - this.p1.getX()\n    const C = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY())\n    const A2plusB2 = A * A + B * B\n    const A2subB2 = A * A - B * B\n    const x = p.getX()\n    const y = p.getY()\n    const rx = (-A2subB2 * x - 2 * A * B * y - 2 * A * C) / A2plusB2\n    const ry = (A2subB2 * y - 2 * A * B * x - 2 * B * C) / A2plusB2\n    return new Coordinate(rx, ry)\n  }\n  pointAlong(segmentLengthFraction) {\n    const coord = new Coordinate()\n    coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x)\n    coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y)\n    return coord\n  }\n  hashCode() {\n    let bits0 = Double.doubleToLongBits(this.p0.x)\n    bits0 ^= Double.doubleToLongBits(this.p0.y) * 31\n    const hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32)\n    let bits1 = Double.doubleToLongBits(this.p1.x)\n    bits1 ^= Double.doubleToLongBits(this.p1.y) * 31\n    const hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32)\n    return hash0 ^ hash1\n  }\n  get interfaces_() {\n    return [Comparable, Serializable]\n  }\n}\n","import LineSegment from '../../geom/LineSegment.js'\nexport default class MonotoneChainOverlapAction {\n  constructor() {\n    MonotoneChainOverlapAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._overlapSeg1 = new LineSegment()\n    this._overlapSeg2 = new LineSegment()\n  }\n  overlap() {\n    if (arguments.length === 2) {\n      const seg1 = arguments[0], seg2 = arguments[1]\n    } else if (arguments.length === 4) {\n      const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3]\n      mc1.getLineSegment(start1, this._overlapSeg1)\n      mc2.getLineSegment(start2, this._overlapSeg2)\n      this.overlap(this._overlapSeg1, this._overlapSeg2)\n    }\n  }\n}\n","import Envelope from '../../geom/Envelope.js'\nexport default class MonotoneChain {\n  constructor() {\n    MonotoneChain.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._pts = null\n    this._start = null\n    this._end = null\n    this._env = null\n    this._context = null\n    this._id = null\n    const pts = arguments[0], start = arguments[1], end = arguments[2], context = arguments[3]\n    this._pts = pts\n    this._start = start\n    this._end = end\n    this._context = context\n  }\n  computeOverlaps() {\n    if (arguments.length === 2) {\n      const mc = arguments[0], mco = arguments[1]\n      this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco)\n    } else if (arguments.length === 6) {\n      const start0 = arguments[0], end0 = arguments[1], mc = arguments[2], start1 = arguments[3], end1 = arguments[4], mco = arguments[5]\n      if (end0 - start0 === 1 && end1 - start1 === 1) {\n        mco.overlap(this, start0, mc, start1)\n        return null\n      }\n      if (!this.overlaps(start0, end0, mc, start1, end1)) return null\n      const mid0 = Math.trunc((start0 + end0) / 2)\n      const mid1 = Math.trunc((start1 + end1) / 2)\n      if (start0 < mid0) {\n        if (start1 < mid1) this.computeOverlaps(start0, mid0, mc, start1, mid1, mco)\n        if (mid1 < end1) this.computeOverlaps(start0, mid0, mc, mid1, end1, mco)\n      }\n      if (mid0 < end0) {\n        if (start1 < mid1) this.computeOverlaps(mid0, end0, mc, start1, mid1, mco)\n        if (mid1 < end1) this.computeOverlaps(mid0, end0, mc, mid1, end1, mco)\n      }\n    }\n  }\n  setId(id) {\n    this._id = id\n  }\n  select(searchEnv, mcs) {\n    this.computeSelect(searchEnv, this._start, this._end, mcs)\n  }\n  getEnvelope() {\n    if (this._env === null) {\n      const p0 = this._pts[this._start]\n      const p1 = this._pts[this._end]\n      this._env = new Envelope(p0, p1)\n    }\n    return this._env\n  }\n  overlaps(start0, end0, mc, start1, end1) {\n    return Envelope.intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1])\n  }\n  getEndIndex() {\n    return this._end\n  }\n  getStartIndex() {\n    return this._start\n  }\n  getContext() {\n    return this._context\n  }\n  getId() {\n    return this._id\n  }\n  getLineSegment(index, ls) {\n    ls.p0 = this._pts[index]\n    ls.p1 = this._pts[index + 1]\n  }\n  computeSelect(searchEnv, start0, end0, mcs) {\n    const p0 = this._pts[start0]\n    const p1 = this._pts[end0]\n    if (end0 - start0 === 1) {\n      mcs.select(this, start0)\n      return null\n    }\n    if (!searchEnv.intersects(p0, p1)) return null\n    const mid = Math.trunc((start0 + end0) / 2)\n    if (start0 < mid) \n      this.computeSelect(searchEnv, start0, mid, mcs)\n    \n    if (mid < end0) \n      this.computeSelect(searchEnv, mid, end0, mcs)\n    \n  }\n  getCoordinates() {\n    const coord = new Array(this._end - this._start + 1).fill(null)\n    let index = 0\n    for (let i = this._start; i <= this._end; i++) \n      coord[index++] = this._pts[i]\n    \n    return coord\n  }\n}\n","import Coordinate from '../geom/Coordinate.js'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException.js'\nexport default class Quadrant {\n  static isNorthern(quad) {\n    return quad === Quadrant.NE || quad === Quadrant.NW\n  }\n  static isOpposite(quad1, quad2) {\n    if (quad1 === quad2) return false\n    const diff = (quad1 - quad2 + 4) % 4\n    if (diff === 2) return true\n    return false\n  }\n  static commonHalfPlane(quad1, quad2) {\n    if (quad1 === quad2) return quad1\n    const diff = (quad1 - quad2 + 4) % 4\n    if (diff === 2) return -1\n    const min = quad1 < quad2 ? quad1 : quad2\n    const max = quad1 > quad2 ? quad1 : quad2\n    if (min === 0 && max === 3) return 3\n    return min\n  }\n  static isInHalfPlane(quad, halfPlane) {\n    if (halfPlane === Quadrant.SE) \n      return quad === Quadrant.SE || quad === Quadrant.SW\n    \n    return quad === halfPlane || quad === halfPlane + 1\n  }\n  static quadrant() {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      const dx = arguments[0], dy = arguments[1]\n      if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )')\n      if (dx >= 0.0) \n        if (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE\n      else \n        if (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW\n      \n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      const p0 = arguments[0], p1 = arguments[1]\n      if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0)\n      if (p1.x >= p0.x) \n        if (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE\n      else \n        if (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW\n      \n    }\n  }\n}\nQuadrant.NE = 0\nQuadrant.NW = 1\nQuadrant.SW = 2\nQuadrant.SE = 3\n","import MonotoneChain from './MonotoneChain.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Quadrant from '../../geomgraph/Quadrant.js'\nexport default class MonotoneChainBuilder {\n  static findChainEnd(pts, start) {\n    let safeStart = start\n    while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) \n      safeStart++\n    \n    if (safeStart >= pts.length - 1) \n      return pts.length - 1\n    \n    const chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1])\n    let last = start + 1\n    while (last < pts.length) {\n      if (!pts[last - 1].equals2D(pts[last])) {\n        const quad = Quadrant.quadrant(pts[last - 1], pts[last])\n        if (quad !== chainQuad) break\n      }\n      last++\n    }\n    return last - 1\n  }\n  static getChains() {\n    if (arguments.length === 1) {\n      const pts = arguments[0]\n      return MonotoneChainBuilder.getChains(pts, null)\n    } else if (arguments.length === 2) {\n      const pts = arguments[0], context = arguments[1]\n      const mcList = new ArrayList()\n      let chainStart = 0\n      do {\n        const chainEnd = MonotoneChainBuilder.findChainEnd(pts, chainStart)\n        const mc = new MonotoneChain(pts, chainStart, chainEnd, context)\n        mcList.add(mc)\n        chainStart = chainEnd\n      } while (chainStart < pts.length - 1)\n      return mcList\n    }\n  }\n}\n","import Noder from './Noder.js'\nexport default class SinglePassNoder {\n  constructor() {\n    SinglePassNoder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._segInt = null\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const segInt = arguments[0]\n      this.setSegmentIntersector(segInt)\n    }\n  }\n  setSegmentIntersector(segInt) {\n    this._segInt = segInt\n  }\n  get interfaces_() {\n    return [Noder]\n  }\n}\n","import STRtree from '../index/strtree/STRtree.js'\nimport NodedSegmentString from './NodedSegmentString.js'\nimport MonotoneChainOverlapAction from '../index/chain/MonotoneChainOverlapAction.js'\nimport MonotoneChainBuilder from '../index/chain/MonotoneChainBuilder.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport SinglePassNoder from './SinglePassNoder.js'\nexport default class MCIndexNoder extends SinglePassNoder {\n  constructor() {\n    super()\n    MCIndexNoder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._monoChains = new ArrayList()\n    this._index = new STRtree()\n    this._idCounter = 0\n    this._nodedSegStrings = null\n    this._nOverlaps = 0\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const si = arguments[0]\n      SinglePassNoder.constructor_.call(this, si)\n    }\n  }\n  getMonotoneChains() {\n    return this._monoChains\n  }\n  getNodedSubstrings() {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n  }\n  getIndex() {\n    return this._index\n  }\n  add(segStr) {\n    const segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr)\n    for (let i = segChains.iterator(); i.hasNext(); ) {\n      const mc = i.next()\n      mc.setId(this._idCounter++)\n      this._index.insert(mc.getEnvelope(), mc)\n      this._monoChains.add(mc)\n    }\n  }\n  computeNodes(inputSegStrings) {\n    this._nodedSegStrings = inputSegStrings\n    for (let i = inputSegStrings.iterator(); i.hasNext(); ) \n      this.add(i.next())\n    \n    this.intersectChains()\n  }\n  intersectChains() {\n    const overlapAction = new SegmentOverlapAction(this._segInt)\n    for (let i = this._monoChains.iterator(); i.hasNext(); ) {\n      const queryChain = i.next()\n      const overlapChains = this._index.query(queryChain.getEnvelope())\n      for (let j = overlapChains.iterator(); j.hasNext(); ) {\n        const testChain = j.next()\n        if (testChain.getId() > queryChain.getId()) {\n          queryChain.computeOverlaps(testChain, overlapAction)\n          this._nOverlaps++\n        }\n        if (this._segInt.isDone()) return null\n      }\n    }\n  }\n}\nclass SegmentOverlapAction extends MonotoneChainOverlapAction {\n  constructor() {\n    super()\n    SegmentOverlapAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._si = null\n    const si = arguments[0]\n    this._si = si\n  }\n  overlap() {\n    if (arguments.length === 4) {\n      const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3]\n      const ss1 = mc1.getContext()\n      const ss2 = mc2.getContext()\n      this._si.processIntersections(ss1, start1, ss2, start2)\n    } else {\n      return super.overlap.apply(this, arguments)\n    }\n  }\n}\nMCIndexNoder.SegmentOverlapAction = SegmentOverlapAction\n","import Coordinate from '../../geom/Coordinate.js'\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException.js'\nimport Envelope from '../../geom/Envelope.js'\nimport Assert from '../../util/Assert.js'\nexport default class HotPixel {\n  constructor() {\n    HotPixel.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._li = null\n    this._pt = null\n    this._originalPt = null\n    this._ptScaled = null\n    this._p0Scaled = null\n    this._p1Scaled = null\n    this._scaleFactor = null\n    this._minx = null\n    this._maxx = null\n    this._miny = null\n    this._maxy = null\n    this._corner = new Array(4).fill(null)\n    this._safeEnv = null\n    const pt = arguments[0], scaleFactor = arguments[1], li = arguments[2]\n    this._originalPt = pt\n    this._pt = pt\n    this._scaleFactor = scaleFactor\n    this._li = li\n    if (scaleFactor <= 0) throw new IllegalArgumentException('Scale factor must be non-zero')\n    if (scaleFactor !== 1.0) {\n      this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y))\n      this._p0Scaled = new Coordinate()\n      this._p1Scaled = new Coordinate()\n    }\n    this.initCorners(this._pt)\n  }\n  intersectsScaled(p0, p1) {\n    const segMinx = Math.min(p0.x, p1.x)\n    const segMaxx = Math.max(p0.x, p1.x)\n    const segMiny = Math.min(p0.y, p1.y)\n    const segMaxy = Math.max(p0.y, p1.y)\n    const isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy\n    if (isOutsidePixelEnv) return false\n    const intersects = this.intersectsToleranceSquare(p0, p1)\n    Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test')\n    return intersects\n  }\n  copyScaled(p, pScaled) {\n    pScaled.x = this.scale(p.x)\n    pScaled.y = this.scale(p.y)\n  }\n  getSafeEnvelope() {\n    if (this._safeEnv === null) {\n      const safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor\n      this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance)\n    }\n    return this._safeEnv\n  }\n  intersectsPixelClosure(p0, p1) {\n    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1])\n    if (this._li.hasIntersection()) return true\n    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2])\n    if (this._li.hasIntersection()) return true\n    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3])\n    if (this._li.hasIntersection()) return true\n    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0])\n    if (this._li.hasIntersection()) return true\n    return false\n  }\n  intersectsToleranceSquare(p0, p1) {\n    let intersectsLeft = false\n    let intersectsBottom = false\n    this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1])\n    if (this._li.isProper()) return true\n    this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2])\n    if (this._li.isProper()) return true\n    if (this._li.hasIntersection()) intersectsLeft = true\n    this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3])\n    if (this._li.isProper()) return true\n    if (this._li.hasIntersection()) intersectsBottom = true\n    this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0])\n    if (this._li.isProper()) return true\n    if (intersectsLeft && intersectsBottom) return true\n    if (p0.equals(this._pt)) return true\n    if (p1.equals(this._pt)) return true\n    return false\n  }\n  addSnappedNode(segStr, segIndex) {\n    const p0 = segStr.getCoordinate(segIndex)\n    const p1 = segStr.getCoordinate(segIndex + 1)\n    if (this.intersects(p0, p1)) {\n      segStr.addIntersection(this.getCoordinate(), segIndex)\n      return true\n    }\n    return false\n  }\n  initCorners(pt) {\n    const tolerance = 0.5\n    this._minx = pt.x - tolerance\n    this._maxx = pt.x + tolerance\n    this._miny = pt.y - tolerance\n    this._maxy = pt.y + tolerance\n    this._corner[0] = new Coordinate(this._maxx, this._maxy)\n    this._corner[1] = new Coordinate(this._minx, this._maxy)\n    this._corner[2] = new Coordinate(this._minx, this._miny)\n    this._corner[3] = new Coordinate(this._maxx, this._miny)\n  }\n  intersects(p0, p1) {\n    if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1)\n    this.copyScaled(p0, this._p0Scaled)\n    this.copyScaled(p1, this._p1Scaled)\n    return this.intersectsScaled(this._p0Scaled, this._p1Scaled)\n  }\n  scale(val) {\n    return Math.round(val * this._scaleFactor)\n  }\n  getCoordinate() {\n    return this._originalPt\n  }\n}\nHotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75\n","import LineSegment from '../../geom/LineSegment.js'\nexport default class MonotoneChainSelectAction {\n  constructor() {\n    MonotoneChainSelectAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.selectedSegment = new LineSegment()\n  }\n  select() {\n    if (arguments.length === 1) {\n      const seg = arguments[0]\n    } else if (arguments.length === 2) {\n      const mc = arguments[0], startIndex = arguments[1]\n      mc.getLineSegment(startIndex, this.selectedSegment)\n      this.select(this.selectedSegment)\n    }\n  }\n}\n","import MonotoneChainSelectAction from '../../index/chain/MonotoneChainSelectAction.js'\nimport MonotoneChain from '../../index/chain/MonotoneChain.js'\nimport ItemVisitor from '../../index/ItemVisitor.js'\nexport default class MCIndexPointSnapper {\n  constructor() {\n    MCIndexPointSnapper.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._index = null\n    const index = arguments[0]\n    this._index = index\n  }\n  snap() {\n    if (arguments.length === 1) {\n      const hotPixel = arguments[0]\n      return this.snap(hotPixel, null, -1)\n    } else if (arguments.length === 3) {\n      const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2]\n      const pixelEnv = hotPixel.getSafeEnvelope()\n      const hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex)\n      this._index.query(pixelEnv, new (class {\n        get interfaces_() {\n          return [ItemVisitor]\n        }\n        visitItem(item) {\n          const testChain = item\n          testChain.select(pixelEnv, hotPixelSnapAction)\n        }\n      })())\n      return hotPixelSnapAction.isNodeAdded()\n    }\n  }\n}\nclass HotPixelSnapAction extends MonotoneChainSelectAction {\n  constructor() {\n    super()\n    HotPixelSnapAction.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._hotPixel = null\n    this._parentEdge = null\n    this._hotPixelVertexIndex = null\n    this._isNodeAdded = false\n    const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2]\n    this._hotPixel = hotPixel\n    this._parentEdge = parentEdge\n    this._hotPixelVertexIndex = hotPixelVertexIndex\n  }\n  select() {\n    if (arguments.length === 2 && (Number.isInteger(arguments[1]) && arguments[0] instanceof MonotoneChain)) {\n      const mc = arguments[0], startIndex = arguments[1]\n      const ss = mc.getContext()\n      if (this._parentEdge === ss) \n        if (startIndex === this._hotPixelVertexIndex || startIndex + 1 === this._hotPixelVertexIndex) return null\n      \n      this._isNodeAdded |= this._hotPixel.addSnappedNode(ss, startIndex)\n    } else {\n      return super.select.apply(this, arguments)\n    }\n  }\n  isNodeAdded() {\n    return this._isNodeAdded\n  }\n}\nMCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction\n","export default class SegmentIntersector {\n  isDone() {}\n  processIntersections(e0, segIndex0, e1, segIndex1) {}\n}\n","import SegmentIntersector from './SegmentIntersector.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nexport default class InteriorIntersectionFinderAdder {\n  constructor() {\n    InteriorIntersectionFinderAdder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._li = null\n    this._interiorIntersections = null\n    const li = arguments[0]\n    this._li = li\n    this._interiorIntersections = new ArrayList()\n  }\n  isDone() {\n    return false\n  }\n  processIntersections(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1 && segIndex0 === segIndex1) return null\n    const p00 = e0.getCoordinates()[segIndex0]\n    const p01 = e0.getCoordinates()[segIndex0 + 1]\n    const p10 = e1.getCoordinates()[segIndex1]\n    const p11 = e1.getCoordinates()[segIndex1 + 1]\n    this._li.computeIntersection(p00, p01, p10, p11)\n    if (this._li.hasIntersection()) \n      if (this._li.isInteriorIntersection()) {\n        for (let intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) \n          this._interiorIntersections.add(this._li.getIntersection(intIndex))\n        \n        e0.addIntersections(this._li, segIndex0, 0)\n        e1.addIntersections(this._li, segIndex1, 1)\n      }\n    \n  }\n  getInteriorIntersections() {\n    return this._interiorIntersections\n  }\n  get interfaces_() {\n    return [SegmentIntersector]\n  }\n}\n","import NodingValidator from '../NodingValidator.js'\nimport hasInterface from '../../../../../hasInterface.js'\nimport MCIndexNoder from '../MCIndexNoder.js'\nimport NodedSegmentString from '../NodedSegmentString.js'\nimport HotPixel from './HotPixel.js'\nimport Exception from '../../../../../java/lang/Exception.js'\nimport MCIndexPointSnapper from './MCIndexPointSnapper.js'\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector.js'\nimport InteriorIntersectionFinderAdder from '../InteriorIntersectionFinderAdder.js'\nimport Collection from '../../../../../java/util/Collection.js'\nimport Noder from '../Noder.js'\nexport default class MCIndexSnapRounder {\n  constructor() {\n    MCIndexSnapRounder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._pm = null\n    this._li = null\n    this._scaleFactor = null\n    this._noder = null\n    this._pointSnapper = null\n    this._nodedSegStrings = null\n    const pm = arguments[0]\n    this._pm = pm\n    this._li = new RobustLineIntersector()\n    this._li.setPrecisionModel(pm)\n    this._scaleFactor = pm.getScale()\n  }\n  checkCorrectness(inputSegmentStrings) {\n    const resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings)\n    const nv = new NodingValidator(resultSegStrings)\n    try {\n      nv.checkValid()\n    } catch (ex) {\n      if (ex instanceof Exception) \n        ex.printStackTrace()\n      else throw ex\n    } finally {}\n  }\n  getNodedSubstrings() {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n  }\n  snapRound(segStrings, li) {\n    const intersections = this.findInteriorIntersections(segStrings, li)\n    this.computeIntersectionSnaps(intersections)\n    this.computeVertexSnaps(segStrings)\n  }\n  findInteriorIntersections(segStrings, li) {\n    const intFinderAdder = new InteriorIntersectionFinderAdder(li)\n    this._noder.setSegmentIntersector(intFinderAdder)\n    this._noder.computeNodes(segStrings)\n    return intFinderAdder.getInteriorIntersections()\n  }\n  computeVertexSnaps() {\n    if (hasInterface(arguments[0], Collection)) {\n      const edges = arguments[0]\n      for (let i0 = edges.iterator(); i0.hasNext(); ) {\n        const edge0 = i0.next()\n        this.computeVertexSnaps(edge0)\n      }\n    } else if (arguments[0] instanceof NodedSegmentString) {\n      const e = arguments[0]\n      const pts0 = e.getCoordinates()\n      for (let i = 0; i < pts0.length; i++) {\n        const hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li)\n        const isNodeAdded = this._pointSnapper.snap(hotPixel, e, i)\n        if (isNodeAdded) \n          e.addIntersection(pts0[i], i)\n        \n      }\n    }\n  }\n  computeNodes(inputSegmentStrings) {\n    this._nodedSegStrings = inputSegmentStrings\n    this._noder = new MCIndexNoder()\n    this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex())\n    this.snapRound(inputSegmentStrings, this._li)\n  }\n  computeIntersectionSnaps(snapPts) {\n    for (let it = snapPts.iterator(); it.hasNext(); ) {\n      const snapPt = it.next()\n      const hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li)\n      this._pointSnapper.snap(hotPixel)\n    }\n  }\n  get interfaces_() {\n    return [Noder]\n  }\n}\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException.js'\nexport default class Location {\n  static toLocationSymbol(locationValue) {\n    switch (locationValue) {\n    case Location.EXTERIOR:\n      return 'e'\n    case Location.BOUNDARY:\n      return 'b'\n    case Location.INTERIOR:\n      return 'i'\n    case Location.NONE:\n      return '-'\n    }\n    throw new IllegalArgumentException('Unknown location value: ' + locationValue)\n  }\n}\nLocation.INTERIOR = 0\nLocation.BOUNDARY = 1\nLocation.EXTERIOR = 2\nLocation.NONE = -1\n","export default class Position {\n  static opposite(position) {\n    if (position === Position.LEFT) return Position.RIGHT\n    if (position === Position.RIGHT) return Position.LEFT\n    return position\n  }\n}\nPosition.ON = 0\nPosition.LEFT = 1\nPosition.RIGHT = 2\n","import Exception from '../lang/Exception.js'\n\nexport default class EmptyStackException extends Exception {\n  constructor(message) {\n    super(message)\n    this.name = Object.keys({ EmptyStackException })[0]\n  }\n}\n","import EmptyStackException from './EmptyStackException.js'\nimport IndexOutOfBoundsException from '../lang/IndexOutOfBoundsException.js'\nimport List from './List.js'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n */\nexport default class Stack extends List {\n  constructor() {\n    super()\n    this.array = []\n  }\n\n  add(e) {\n    this.array.push(e)\n    return true\n  }\n\n  get(index) {\n    if (index < 0 || index >= this.size())\n      throw new IndexOutOfBoundsException()\n    return this.array[index]\n  }\n\n  /**\n   * Pushes an item onto the top of this stack.\n   * @param {Object} e\n   * @return {Object}\n   */\n  push(e) {\n    this.array.push(e)\n    return e\n  }\n\n  /**\n   * Removes the object at the top of this stack and returns that object as the value of this function.\n   * @return {Object}\n   */\n  pop() {\n    if (this.array.length === 0)\n      throw new EmptyStackException()\n    return this.array.pop()\n  }\n\n  /**\n   * Looks at the object at the top of this stack without removing it from the\n   * stack.\n   * @return {Object}\n   */\n  peek() {\n    if (this.array.length === 0)\n      throw new EmptyStackException()\n    return this.array[this.array.length - 1]\n  }\n\n  /**\n   * Tests if this stack is empty.\n   * @return {boolean} true if and only if this stack contains no items; false\n   *         otherwise.\n   */\n  empty() {\n    return this.array.length === 0\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    return this.empty()\n  }\n\n  /**\n   * Returns the 1-based position where an object is on this stack. If the object\n   * o occurs as an item in this stack, this method returns the distance from the\n   * top of the stack of the occurrence nearest the top of the stack; the topmost\n   * item on the stack is considered to be at distance 1. The equals method is\n   * used to compare o to the items in this stack.\n   *\n   * NOTE: does not currently actually use equals. (=== is used)\n   *\n   * @param {Object} o\n   * @return {number} the 1-based position from the top of the stack where the\n   *         object is located; the return value -1 indicates that the object is\n   *         not on the stack.\n   */\n  search(o) {\n    return this.array.indexOf(o)\n  }\n\n  /**\n   * @return {number}\n   */\n  size() {\n    return this.array.length\n  }\n\n  /**\n   * @return {Array}\n   */\n  toArray() {\n    return this.array.slice()\n  }\n}\n","import Position from '../../geomgraph/Position.js'\nimport Orientation from '../../algorithm/Orientation.js'\nimport Assert from '../../util/Assert.js'\nexport default class RightmostEdgeFinder {\n  constructor() {\n    RightmostEdgeFinder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._minIndex = -1\n    this._minCoord = null\n    this._minDe = null\n    this._orientedDe = null\n  }\n  getCoordinate() {\n    return this._minCoord\n  }\n  getRightmostSide(de, index) {\n    let side = this.getRightmostSideOfSegment(de, index)\n    if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1)\n    if (side < 0) {\n      this._minCoord = null\n      this.checkForRightmostCoordinate(de)\n    }\n    return side\n  }\n  findRightmostEdgeAtVertex() {\n    const pts = this._minDe.getEdge().getCoordinates()\n    Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge')\n    const pPrev = pts[this._minIndex - 1]\n    const pNext = pts[this._minIndex + 1]\n    const orientation = Orientation.index(this._minCoord, pNext, pPrev)\n    let usePrev = false\n    if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === Orientation.COUNTERCLOCKWISE) \n      usePrev = true\n    else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === Orientation.CLOCKWISE) \n      usePrev = true\n    \n    if (usePrev) \n      this._minIndex = this._minIndex - 1\n    \n  }\n  getRightmostSideOfSegment(de, i) {\n    const e = de.getEdge()\n    const coord = e.getCoordinates()\n    if (i < 0 || i + 1 >= coord.length) return -1\n    if (coord[i].y === coord[i + 1].y) return -1\n    let pos = Position.LEFT\n    if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT\n    return pos\n  }\n  getEdge() {\n    return this._orientedDe\n  }\n  checkForRightmostCoordinate(de) {\n    const coord = de.getEdge().getCoordinates()\n    for (let i = 0; i < coord.length - 1; i++) \n      if (this._minCoord === null || coord[i].x > this._minCoord.x) {\n        this._minDe = de\n        this._minIndex = i\n        this._minCoord = coord[i]\n      }\n    \n  }\n  findRightmostEdgeAtNode() {\n    const node = this._minDe.getNode()\n    const star = node.getEdges()\n    this._minDe = star.getRightmostEdge()\n    if (!this._minDe.isForward()) {\n      this._minDe = this._minDe.getSym()\n      this._minIndex = this._minDe.getEdge().getCoordinates().length - 1\n    }\n  }\n  findEdge(dirEdgeList) {\n    for (let i = dirEdgeList.iterator(); i.hasNext(); ) {\n      const de = i.next()\n      if (!de.isForward()) continue\n      this.checkForRightmostCoordinate(de)\n    }\n    Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing')\n    if (this._minIndex === 0) \n      this.findRightmostEdgeAtNode()\n    else \n      this.findRightmostEdgeAtVertex()\n    \n    this._orientedDe = this._minDe\n    const rightmostSide = this.getRightmostSide(this._minDe, this._minIndex)\n    if (rightmostSide === Position.LEFT) \n      this._orientedDe = this._minDe.getSym()\n    \n  }\n}\n","export default class LinkedList {\n  constructor() {\n    this.array = []\n  }\n\n  addLast(e) {\n    this.array.push(e)\n  }\n\n  removeFirst() {\n    return this.array.shift()\n  }\n\n  isEmpty() {\n    return this.array.length === 0\n  }\n}\n","import HashSet from '../../../../../java/util/HashSet.js'\nimport Position from '../../geomgraph/Position.js'\nimport Stack from '../../../../../java/util/Stack.js'\nimport RightmostEdgeFinder from './RightmostEdgeFinder.js'\nimport TopologyException from '../../geom/TopologyException.js'\nimport LinkedList from '../../../../../java/util/LinkedList.js'\nimport Comparable from '../../../../../java/lang/Comparable.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Envelope from '../../geom/Envelope.js'\nexport default class BufferSubgraph {\n  constructor() {\n    BufferSubgraph.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._finder = null\n    this._dirEdgeList = new ArrayList()\n    this._nodes = new ArrayList()\n    this._rightMostCoord = null\n    this._env = null\n    this._finder = new RightmostEdgeFinder()\n  }\n  clearVisitedEdges() {\n    for (let it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      de.setVisited(false)\n    }\n  }\n  compareTo(o) {\n    const graph = o\n    if (this._rightMostCoord.x < graph._rightMostCoord.x) \n      return -1\n    \n    if (this._rightMostCoord.x > graph._rightMostCoord.x) \n      return 1\n    \n    return 0\n  }\n  getEnvelope() {\n    if (this._env === null) {\n      const edgeEnv = new Envelope()\n      for (let it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n        const dirEdge = it.next()\n        const pts = dirEdge.getEdge().getCoordinates()\n        for (let i = 0; i < pts.length - 1; i++) \n          edgeEnv.expandToInclude(pts[i])\n        \n      }\n      this._env = edgeEnv\n    }\n    return this._env\n  }\n  addReachable(startNode) {\n    const nodeStack = new Stack()\n    nodeStack.add(startNode)\n    while (!nodeStack.empty()) {\n      const node = nodeStack.pop()\n      this.add(node, nodeStack)\n    }\n  }\n  copySymDepths(de) {\n    const sym = de.getSym()\n    sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT))\n    sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT))\n  }\n  add(node, nodeStack) {\n    node.setVisited(true)\n    this._nodes.add(node)\n    for (let i = node.getEdges().iterator(); i.hasNext(); ) {\n      const de = i.next()\n      this._dirEdgeList.add(de)\n      const sym = de.getSym()\n      const symNode = sym.getNode()\n      if (!symNode.isVisited()) nodeStack.push(symNode)\n    }\n  }\n  getRightmostCoordinate() {\n    return this._rightMostCoord\n  }\n  computeNodeDepth(n) {\n    let startEdge = null\n    for (let i = n.getEdges().iterator(); i.hasNext(); ) {\n      const de = i.next()\n      if (de.isVisited() || de.getSym().isVisited()) {\n        startEdge = de\n        break\n      }\n    }\n    if (startEdge === null) throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate())\n    n.getEdges().computeDepths(startEdge)\n    for (let i = n.getEdges().iterator(); i.hasNext(); ) {\n      const de = i.next()\n      de.setVisited(true)\n      this.copySymDepths(de)\n    }\n  }\n  computeDepth(outsideDepth) {\n    this.clearVisitedEdges()\n    const de = this._finder.getEdge()\n    const n = de.getNode()\n    const label = de.getLabel()\n    de.setEdgeDepths(Position.RIGHT, outsideDepth)\n    this.copySymDepths(de)\n    this.computeDepths(de)\n  }\n  create(node) {\n    this.addReachable(node)\n    this._finder.findEdge(this._dirEdgeList)\n    this._rightMostCoord = this._finder.getCoordinate()\n  }\n  findResultEdges() {\n    for (let it = this._dirEdgeList.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) \n        de.setInResult(true)\n      \n    }\n  }\n  computeDepths(startEdge) {\n    const nodesVisited = new HashSet()\n    const nodeQueue = new LinkedList()\n    const startNode = startEdge.getNode()\n    nodeQueue.addLast(startNode)\n    nodesVisited.add(startNode)\n    startEdge.setVisited(true)\n    while (!nodeQueue.isEmpty()) {\n      const n = nodeQueue.removeFirst()\n      nodesVisited.add(n)\n      this.computeNodeDepth(n)\n      for (let i = n.getEdges().iterator(); i.hasNext(); ) {\n        const de = i.next()\n        const sym = de.getSym()\n        if (sym.isVisited()) continue\n        const adjNode = sym.getNode()\n        if (!nodesVisited.contains(adjNode)) {\n          nodeQueue.addLast(adjNode)\n          nodesVisited.add(adjNode)\n        }\n      }\n    }\n  }\n  getNodes() {\n    return this._nodes\n  }\n  getDirectedEdges() {\n    return this._dirEdgeList\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import CoordinateList from '../../geom/CoordinateList.js'\nimport Orientation from '../../algorithm/Orientation.js'\nimport Distance from '../../algorithm/Distance.js'\nexport default class BufferInputLineSimplifier {\n  constructor() {\n    BufferInputLineSimplifier.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._inputLine = null\n    this._distanceTol = null\n    this._isDeleted = null\n    this._angleOrientation = Orientation.COUNTERCLOCKWISE\n    const inputLine = arguments[0]\n    this._inputLine = inputLine\n  }\n  static simplify(inputLine, distanceTol) {\n    const simp = new BufferInputLineSimplifier(inputLine)\n    return simp.simplify(distanceTol)\n  }\n  isDeletable(i0, i1, i2, distanceTol) {\n    const p0 = this._inputLine[i0]\n    const p1 = this._inputLine[i1]\n    const p2 = this._inputLine[i2]\n    if (!this.isConcave(p0, p1, p2)) return false\n    if (!this.isShallow(p0, p1, p2, distanceTol)) return false\n    return this.isShallowSampled(p0, p1, i0, i2, distanceTol)\n  }\n  deleteShallowConcavities() {\n    let index = 1\n    let midIndex = this.findNextNonDeletedIndex(index)\n    let lastIndex = this.findNextNonDeletedIndex(midIndex)\n    let isChanged = false\n    while (lastIndex < this._inputLine.length) {\n      let isMiddleVertexDeleted = false\n      if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n        this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE\n        isMiddleVertexDeleted = true\n        isChanged = true\n      }\n      if (isMiddleVertexDeleted) index = lastIndex; else index = midIndex\n      midIndex = this.findNextNonDeletedIndex(index)\n      lastIndex = this.findNextNonDeletedIndex(midIndex)\n    }\n    return isChanged\n  }\n  isShallowConcavity(p0, p1, p2, distanceTol) {\n    const orientation = Orientation.index(p0, p1, p2)\n    const isAngleToSimplify = orientation === this._angleOrientation\n    if (!isAngleToSimplify) return false\n    const dist = Distance.pointToSegment(p1, p0, p2)\n    return dist < distanceTol\n  }\n  isShallowSampled(p0, p2, i0, i2, distanceTol) {\n    let inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK)\n    if (inc <= 0) inc = 1\n    for (let i = i0; i < i2; i += inc) \n      if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false\n    \n    return true\n  }\n  isConcave(p0, p1, p2) {\n    const orientation = Orientation.index(p0, p1, p2)\n    const isConcave = orientation === this._angleOrientation\n    return isConcave\n  }\n  simplify(distanceTol) {\n    this._distanceTol = Math.abs(distanceTol)\n    if (distanceTol < 0) this._angleOrientation = Orientation.CLOCKWISE\n    this._isDeleted = new Array(this._inputLine.length).fill(null)\n    let isChanged = false\n    do \n      isChanged = this.deleteShallowConcavities()\n    while (isChanged)\n    return this.collapseLine()\n  }\n  findNextNonDeletedIndex(index) {\n    let next = index + 1\n    while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) next++\n    return next\n  }\n  isShallow(p0, p1, p2, distanceTol) {\n    const dist = Distance.pointToSegment(p1, p0, p2)\n    return dist < distanceTol\n  }\n  collapseLine() {\n    const coordList = new CoordinateList()\n    for (let i = 0; i < this._inputLine.length; i++) \n      if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i])\n    \n    return coordList.toCoordinateArray()\n  }\n}\nBufferInputLineSimplifier.INIT = 0\nBufferInputLineSimplifier.DELETE = 1\nBufferInputLineSimplifier.KEEP = 1\nBufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10\n","import GeometryFactory from '../../geom/GeometryFactory.js'\nimport Coordinate from '../../geom/Coordinate.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nexport default class OffsetSegmentString {\n  constructor() {\n    OffsetSegmentString.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._ptList = null\n    this._precisionModel = null\n    this._minimimVertexDistance = 0.0\n    this._ptList = new ArrayList()\n  }\n  getCoordinates() {\n    const coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE)\n    return coord\n  }\n  setPrecisionModel(precisionModel) {\n    this._precisionModel = precisionModel\n  }\n  addPt(pt) {\n    const bufPt = new Coordinate(pt)\n    this._precisionModel.makePrecise(bufPt)\n    if (this.isRedundant(bufPt)) return null\n    this._ptList.add(bufPt)\n  }\n  reverse() {}\n  addPts(pt, isForward) {\n    if (isForward) \n      for (let i = 0; i < pt.length; i++) \n        this.addPt(pt[i])\n      \n    else \n      for (let i = pt.length - 1; i >= 0; i--) \n        this.addPt(pt[i])\n      \n    \n  }\n  isRedundant(pt) {\n    if (this._ptList.size() < 1) return false\n    const lastPt = this._ptList.get(this._ptList.size() - 1)\n    const ptDist = pt.distance(lastPt)\n    if (ptDist < this._minimimVertexDistance) return true\n    return false\n  }\n  toString() {\n    const fact = new GeometryFactory()\n    const line = fact.createLineString(this.getCoordinates())\n    return line.toString()\n  }\n  closeRing() {\n    if (this._ptList.size() < 1) return null\n    const startPt = new Coordinate(this._ptList.get(0))\n    const lastPt = this._ptList.get(this._ptList.size() - 1)\n    if (startPt.equals(lastPt)) return null\n    this._ptList.add(startPt)\n  }\n  setMinimumVertexDistance(minimimVertexDistance) {\n    this._minimimVertexDistance = minimimVertexDistance\n  }\n}\nOffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null)\n","import Orientation from './Orientation.js'\nexport default class Angle {\n  static toDegrees(radians) {\n    return radians * 180 / Math.PI\n  }\n  static isAcute(p0, p1, p2) {\n    const dx0 = p0.x - p1.x\n    const dy0 = p0.y - p1.y\n    const dx1 = p2.x - p1.x\n    const dy1 = p2.y - p1.y\n    const dotprod = dx0 * dx1 + dy0 * dy1\n    return dotprod > 0\n  }\n  static isObtuse(p0, p1, p2) {\n    const dx0 = p0.x - p1.x\n    const dy0 = p0.y - p1.y\n    const dx1 = p2.x - p1.x\n    const dy1 = p2.y - p1.y\n    const dotprod = dx0 * dx1 + dy0 * dy1\n    return dotprod < 0\n  }\n  static interiorAngle(p0, p1, p2) {\n    const anglePrev = Angle.angle(p1, p0)\n    const angleNext = Angle.angle(p1, p2)\n    return Math.abs(angleNext - anglePrev)\n  }\n  static normalizePositive(angle) {\n    if (angle < 0.0) {\n      while (angle < 0.0) angle += Angle.PI_TIMES_2\n      if (angle >= Angle.PI_TIMES_2) angle = 0.0\n    } else {\n      while (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2\n      if (angle < 0.0) angle = 0.0\n    }\n    return angle\n  }\n  static angleBetween(tip1, tail, tip2) {\n    const a1 = Angle.angle(tail, tip1)\n    const a2 = Angle.angle(tail, tip2)\n    return Angle.diff(a1, a2)\n  }\n  static diff(ang1, ang2) {\n    let delAngle = null\n    if (ang1 < ang2) \n      delAngle = ang2 - ang1\n    else \n      delAngle = ang1 - ang2\n    \n    if (delAngle > Math.PI) \n      delAngle = 2 * Math.PI - delAngle\n    \n    return delAngle\n  }\n  static toRadians(angleDegrees) {\n    return angleDegrees * Math.PI / 180.0\n  }\n  static normalize(angle) {\n    while (angle > Math.PI) angle -= Angle.PI_TIMES_2\n    while (angle <= -Math.PI) angle += Angle.PI_TIMES_2\n    return angle\n  }\n  static angle() {\n    if (arguments.length === 1) {\n      const p = arguments[0]\n      return Math.atan2(p.y, p.x)\n    } else if (arguments.length === 2) {\n      const p0 = arguments[0], p1 = arguments[1]\n      const dx = p1.x - p0.x\n      const dy = p1.y - p0.y\n      return Math.atan2(dy, dx)\n    }\n  }\n  static getTurn(ang1, ang2) {\n    const crossproduct = Math.sin(ang2 - ang1)\n    if (crossproduct > 0) \n      return Angle.COUNTERCLOCKWISE\n    \n    if (crossproduct < 0) \n      return Angle.CLOCKWISE\n    \n    return Angle.NONE\n  }\n  static angleBetweenOriented(tip1, tail, tip2) {\n    const a1 = Angle.angle(tail, tip1)\n    const a2 = Angle.angle(tail, tip2)\n    const angDel = a2 - a1\n    if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2\n    if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2\n    return angDel\n  }\n}\nAngle.PI_TIMES_2 = 2.0 * Math.PI\nAngle.PI_OVER_2 = Math.PI / 2.0\nAngle.PI_OVER_4 = Math.PI / 4.0\nAngle.COUNTERCLOCKWISE = Orientation.COUNTERCLOCKWISE\nAngle.CLOCKWISE = Orientation.CLOCKWISE\nAngle.NONE = Orientation.COLLINEAR\n","import BufferParameters from './BufferParameters.js'\nimport Position from '../../geomgraph/Position.js'\nimport Coordinate from '../../geom/Coordinate.js'\nimport LineSegment from '../../geom/LineSegment.js'\nimport OffsetSegmentString from './OffsetSegmentString.js'\nimport Orientation from '../../algorithm/Orientation.js'\nimport Intersection from '../../algorithm/Intersection.js'\nimport Angle from '../../algorithm/Angle.js'\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector.js'\nexport default class OffsetSegmentGenerator {\n  constructor() {\n    OffsetSegmentGenerator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._maxCurveSegmentError = 0.0\n    this._filletAngleQuantum = null\n    this._closingSegLengthFactor = 1\n    this._segList = null\n    this._distance = 0.0\n    this._precisionModel = null\n    this._bufParams = null\n    this._li = null\n    this._s0 = null\n    this._s1 = null\n    this._s2 = null\n    this._seg0 = new LineSegment()\n    this._seg1 = new LineSegment()\n    this._offset0 = new LineSegment()\n    this._offset1 = new LineSegment()\n    this._side = 0\n    this._hasNarrowConcaveAngle = false\n    const precisionModel = arguments[0], bufParams = arguments[1], distance = arguments[2]\n    this._precisionModel = precisionModel\n    this._bufParams = bufParams\n    this._li = new RobustLineIntersector()\n    this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments()\n    if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR\n    this.init(distance)\n  }\n  getCoordinates() {\n    const pts = this._segList.getCoordinates()\n    return pts\n  }\n  addMitreJoin(p, offset0, offset1, distance) {\n    const intPt = Intersection.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1)\n    if (intPt !== null) {\n      const mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance)\n      if (mitreRatio <= this._bufParams.getMitreLimit()) {\n        this._segList.addPt(intPt)\n        return null\n      }\n    }\n    this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit())\n  }\n  addLastSegment() {\n    this._segList.addPt(this._offset1.p1)\n  }\n  initSideSegments(s1, s2, side) {\n    this._s1 = s1\n    this._s2 = s2\n    this._side = side\n    this._seg1.setCoordinates(s1, s2)\n    this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1)\n  }\n  addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n    const basePt = this._seg0.p1\n    const ang0 = Angle.angle(basePt, this._seg0.p0)\n    const angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1)\n    const angDiffHalf = angDiff / 2\n    const midAng = Angle.normalize(ang0 + angDiffHalf)\n    const mitreMidAng = Angle.normalize(midAng + Math.PI)\n    const mitreDist = mitreLimit * distance\n    const bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf))\n    const bevelHalfLen = distance - bevelDelta\n    const bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng)\n    const bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng)\n    const bevelMidPt = new Coordinate(bevelMidX, bevelMidY)\n    const mitreMidLine = new LineSegment(basePt, bevelMidPt)\n    const bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen)\n    const bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen)\n    if (this._side === Position.LEFT) {\n      this._segList.addPt(bevelEndLeft)\n      this._segList.addPt(bevelEndRight)\n    } else {\n      this._segList.addPt(bevelEndRight)\n      this._segList.addPt(bevelEndLeft)\n    }\n  }\n  addDirectedFillet(p, startAngle, endAngle, direction, radius) {\n    const directionFactor = direction === Orientation.CLOCKWISE ? -1 : 1\n    const totalAngle = Math.abs(startAngle - endAngle)\n    const nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5)\n    if (nSegs < 1) return null\n    const angleInc = totalAngle / nSegs\n    const pt = new Coordinate()\n    for (let i = 0; i < nSegs; i++) {\n      const angle = startAngle + directionFactor * i * angleInc\n      pt.x = p.x + radius * Math.cos(angle)\n      pt.y = p.y + radius * Math.sin(angle)\n      this._segList.addPt(pt)\n    }\n  }\n  computeOffsetSegment(seg, side, distance, offset) {\n    const sideSign = side === Position.LEFT ? 1 : -1\n    const dx = seg.p1.x - seg.p0.x\n    const dy = seg.p1.y - seg.p0.y\n    const len = Math.sqrt(dx * dx + dy * dy)\n    const ux = sideSign * distance * dx / len\n    const uy = sideSign * distance * dy / len\n    offset.p0.x = seg.p0.x - uy\n    offset.p0.y = seg.p0.y + ux\n    offset.p1.x = seg.p1.x - uy\n    offset.p1.y = seg.p1.y + ux\n  }\n  addInsideTurn(orientation, addStartPoint) {\n    this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1)\n    if (this._li.hasIntersection()) {\n      this._segList.addPt(this._li.getIntersection(0))\n    } else {\n      this._hasNarrowConcaveAngle = true\n      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n        this._segList.addPt(this._offset0.p1)\n      } else {\n        this._segList.addPt(this._offset0.p1)\n        if (this._closingSegLengthFactor > 0) {\n          const mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1))\n          this._segList.addPt(mid0)\n          const mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1))\n          this._segList.addPt(mid1)\n        } else {\n          this._segList.addPt(this._s1)\n        }\n        this._segList.addPt(this._offset1.p0)\n      }\n    }\n  }\n  createCircle(p) {\n    const pt = new Coordinate(p.x + this._distance, p.y)\n    this._segList.addPt(pt)\n    this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance)\n    this._segList.closeRing()\n  }\n  addBevelJoin(offset0, offset1) {\n    this._segList.addPt(offset0.p1)\n    this._segList.addPt(offset1.p0)\n  }\n  init(distance) {\n    this._distance = distance\n    this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0))\n    this._segList = new OffsetSegmentString()\n    this._segList.setPrecisionModel(this._precisionModel)\n    this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)\n  }\n  addCollinear(addStartPoint) {\n    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2)\n    const numInt = this._li.getIntersectionNum()\n    if (numInt >= 2) \n      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n        if (addStartPoint) this._segList.addPt(this._offset0.p1)\n        this._segList.addPt(this._offset1.p0)\n      } else {\n        this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Orientation.CLOCKWISE, this._distance)\n      }\n    \n  }\n  addNextSegment(p, addStartPoint) {\n    this._s0 = this._s1\n    this._s1 = this._s2\n    this._s2 = p\n    this._seg0.setCoordinates(this._s0, this._s1)\n    this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0)\n    this._seg1.setCoordinates(this._s1, this._s2)\n    this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1)\n    if (this._s1.equals(this._s2)) return null\n    const orientation = Orientation.index(this._s0, this._s1, this._s2)\n    const outsideTurn = orientation === Orientation.CLOCKWISE && this._side === Position.LEFT || orientation === Orientation.COUNTERCLOCKWISE && this._side === Position.RIGHT\n    if (orientation === 0) \n      this.addCollinear(addStartPoint)\n    else if (outsideTurn) \n      this.addOutsideTurn(orientation, addStartPoint)\n    else \n      this.addInsideTurn(orientation, addStartPoint)\n    \n  }\n  addLineEndCap(p0, p1) {\n    const seg = new LineSegment(p0, p1)\n    const offsetL = new LineSegment()\n    this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL)\n    const offsetR = new LineSegment()\n    this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR)\n    const dx = p1.x - p0.x\n    const dy = p1.y - p0.y\n    const angle = Math.atan2(dy, dx)\n    switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      this._segList.addPt(offsetL.p1)\n      this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, this._distance)\n      this._segList.addPt(offsetR.p1)\n      break\n    case BufferParameters.CAP_FLAT:\n      this._segList.addPt(offsetL.p1)\n      this._segList.addPt(offsetR.p1)\n      break\n    case BufferParameters.CAP_SQUARE:\n      const squareCapSideOffset = new Coordinate()\n      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle)\n      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle)\n      const squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y)\n      const squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y)\n      this._segList.addPt(squareCapLOffset)\n      this._segList.addPt(squareCapROffset)\n      break\n    }\n  }\n  addOutsideTurn(orientation, addStartPoint) {\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n      this._segList.addPt(this._offset0.p1)\n      return null\n    }\n    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n      this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance)\n    } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n      this.addBevelJoin(this._offset0, this._offset1)\n    } else {\n      if (addStartPoint) this._segList.addPt(this._offset0.p1)\n      this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance)\n      this._segList.addPt(this._offset1.p0)\n    }\n  }\n  createSquare(p) {\n    this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance))\n    this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance))\n    this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance))\n    this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance))\n    this._segList.closeRing()\n  }\n  addSegments(pt, isForward) {\n    this._segList.addPts(pt, isForward)\n  }\n  addFirstSegment() {\n    this._segList.addPt(this._offset1.p0)\n  }\n  addCornerFillet(p, p0, p1, direction, radius) {\n    const dx0 = p0.x - p.x\n    const dy0 = p0.y - p.y\n    let startAngle = Math.atan2(dy0, dx0)\n    const dx1 = p1.x - p.x\n    const dy1 = p1.y - p.y\n    const endAngle = Math.atan2(dy1, dx1)\n    if (direction === Orientation.CLOCKWISE) {\n      if (startAngle <= endAngle) startAngle += 2.0 * Math.PI\n    } else {\n      if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI\n    }\n    this._segList.addPt(p0)\n    this.addDirectedFillet(p, startAngle, endAngle, direction, radius)\n    this._segList.addPt(p1)\n  }\n  closeRing() {\n    this._segList.closeRing()\n  }\n  hasNarrowConcaveAngle() {\n    return this._hasNarrowConcaveAngle\n  }\n}\nOffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3\nOffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3\nOffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6\nOffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80\n","import BufferParameters from './BufferParameters.js'\nimport Position from '../../geomgraph/Position.js'\nimport Coordinate from '../../geom/Coordinate.js'\nimport BufferInputLineSimplifier from './BufferInputLineSimplifier.js'\nimport CoordinateArrays from '../../geom/CoordinateArrays.js'\nimport OffsetSegmentGenerator from './OffsetSegmentGenerator.js'\nexport default class OffsetCurveBuilder {\n  constructor() {\n    OffsetCurveBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._distance = 0.0\n    this._precisionModel = null\n    this._bufParams = null\n    const precisionModel = arguments[0], bufParams = arguments[1]\n    this._precisionModel = precisionModel\n    this._bufParams = bufParams\n  }\n  static copyCoordinates(pts) {\n    const copy = new Array(pts.length).fill(null)\n    for (let i = 0; i < copy.length; i++) \n      copy[i] = new Coordinate(pts[i])\n    \n    return copy\n  }\n  getOffsetCurve(inputPts, distance) {\n    this._distance = distance\n    if (distance === 0.0) return null\n    const isRightSide = distance < 0.0\n    const posDistance = Math.abs(distance)\n    const segGen = this.getSegGen(posDistance)\n    if (inputPts.length <= 1) \n      this.computePointCurve(inputPts[0], segGen)\n    else \n      this.computeOffsetCurve(inputPts, isRightSide, segGen)\n    \n    const curvePts = segGen.getCoordinates()\n    if (isRightSide) CoordinateArrays.reverse(curvePts)\n    return curvePts\n  }\n  computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n    const distTol = this.simplifyTolerance(this._distance)\n    if (isRightSide) {\n      segGen.addSegments(inputPts, true)\n      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol)\n      const n2 = simp2.length - 1\n      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = n2 - 2; i >= 0; i--) \n        segGen.addNextSegment(simp2[i], true)\n      \n    } else {\n      segGen.addSegments(inputPts, false)\n      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol)\n      const n1 = simp1.length - 1\n      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = 2; i <= n1; i++) \n        segGen.addNextSegment(simp1[i], true)\n      \n    }\n    segGen.addLastSegment()\n    segGen.closeRing()\n  }\n  computeRingBufferCurve(inputPts, side, segGen) {\n    let distTol = this.simplifyTolerance(this._distance)\n    if (side === Position.RIGHT) distTol = -distTol\n    const simp = BufferInputLineSimplifier.simplify(inputPts, distTol)\n    const n = simp.length - 1\n    segGen.initSideSegments(simp[n - 1], simp[0], side)\n    for (let i = 1; i <= n; i++) {\n      const addStartPoint = i !== 1\n      segGen.addNextSegment(simp[i], addStartPoint)\n    }\n    segGen.closeRing()\n  }\n  computeLineBufferCurve(inputPts, segGen) {\n    const distTol = this.simplifyTolerance(this._distance)\n    const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol)\n    const n1 = simp1.length - 1\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT)\n    for (let i = 2; i <= n1; i++) \n      segGen.addNextSegment(simp1[i], true)\n    \n    segGen.addLastSegment()\n    segGen.addLineEndCap(simp1[n1 - 1], simp1[n1])\n    const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol)\n    const n2 = simp2.length - 1\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT)\n    for (let i = n2 - 2; i >= 0; i--) \n      segGen.addNextSegment(simp2[i], true)\n    \n    segGen.addLastSegment()\n    segGen.addLineEndCap(simp2[1], simp2[0])\n    segGen.closeRing()\n  }\n  computePointCurve(pt, segGen) {\n    switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      segGen.createCircle(pt)\n      break\n    case BufferParameters.CAP_SQUARE:\n      segGen.createSquare(pt)\n      break\n    }\n  }\n  getLineCurve(inputPts, distance) {\n    this._distance = distance\n    if (this.isLineOffsetEmpty(distance)) return null\n    const posDistance = Math.abs(distance)\n    const segGen = this.getSegGen(posDistance)\n    if (inputPts.length <= 1) {\n      this.computePointCurve(inputPts[0], segGen)\n    } else \n      if (this._bufParams.isSingleSided()) {\n        const isRightSide = distance < 0.0\n        this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen)\n      } else {\n        this.computeLineBufferCurve(inputPts, segGen)\n      }\n    \n    const lineCoord = segGen.getCoordinates()\n    return lineCoord\n  }\n  getBufferParameters() {\n    return this._bufParams\n  }\n  simplifyTolerance(bufDistance) {\n    return bufDistance * this._bufParams.getSimplifyFactor()\n  }\n  getRingCurve(inputPts, side, distance) {\n    this._distance = distance\n    if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance)\n    if (distance === 0.0) \n      return OffsetCurveBuilder.copyCoordinates(inputPts)\n    \n    const segGen = this.getSegGen(distance)\n    this.computeRingBufferCurve(inputPts, side, segGen)\n    return segGen.getCoordinates()\n  }\n  computeOffsetCurve(inputPts, isRightSide, segGen) {\n    const distTol = this.simplifyTolerance(this._distance)\n    if (isRightSide) {\n      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol)\n      const n2 = simp2.length - 1\n      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = n2 - 2; i >= 0; i--) \n        segGen.addNextSegment(simp2[i], true)\n      \n    } else {\n      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol)\n      const n1 = simp1.length - 1\n      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT)\n      segGen.addFirstSegment()\n      for (let i = 2; i <= n1; i++) \n        segGen.addNextSegment(simp1[i], true)\n      \n    }\n    segGen.addLastSegment()\n  }\n  isLineOffsetEmpty(distance) {\n    if (distance === 0.0) return true\n    if (distance < 0.0 && !this._bufParams.isSingleSided()) return true\n    return false\n  }\n  getSegGen(distance) {\n    return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)\n  }\n}\n","import StringBuffer from '../../../../java/lang/StringBuffer.js'\nimport Location from '../geom/Location.js'\nimport Position from './Position.js'\nexport default class TopologyLocation {\n  constructor() {\n    TopologyLocation.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.location = null\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof Array) {\n        const location = arguments[0]\n        this.init(location.length)\n      } else if (Number.isInteger(arguments[0])) {\n        const on = arguments[0]\n        this.init(1)\n        this.location[Position.ON] = on\n      } else if (arguments[0] instanceof TopologyLocation) {\n        const gl = arguments[0]\n        this.init(gl.location.length)\n        if (gl !== null) \n          for (let i = 0; i < this.location.length; i++) \n            this.location[i] = gl.location[i]\n          \n        \n      }\n    } else if (arguments.length === 3) {\n      const on = arguments[0], left = arguments[1], right = arguments[2]\n      this.init(3)\n      this.location[Position.ON] = on\n      this.location[Position.LEFT] = left\n      this.location[Position.RIGHT] = right\n    }\n  }\n  setAllLocations(locValue) {\n    for (let i = 0; i < this.location.length; i++) \n      this.location[i] = locValue\n    \n  }\n  isNull() {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] !== Location.NONE) return false\n    \n    return true\n  }\n  setAllLocationsIfNull(locValue) {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] === Location.NONE) this.location[i] = locValue\n    \n  }\n  isLine() {\n    return this.location.length === 1\n  }\n  merge(gl) {\n    if (gl.location.length > this.location.length) {\n      const newLoc = new Array(3).fill(null)\n      newLoc[Position.ON] = this.location[Position.ON]\n      newLoc[Position.LEFT] = Location.NONE\n      newLoc[Position.RIGHT] = Location.NONE\n      this.location = newLoc\n    }\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i]\n    \n  }\n  getLocations() {\n    return this.location\n  }\n  flip() {\n    if (this.location.length <= 1) return null\n    const temp = this.location[Position.LEFT]\n    this.location[Position.LEFT] = this.location[Position.RIGHT]\n    this.location[Position.RIGHT] = temp\n  }\n  get(posIndex) {\n    if (posIndex < this.location.length) return this.location[posIndex]\n    return Location.NONE\n  }\n  isEqualOnSide(le, locIndex) {\n    return this.location[locIndex] === le.location[locIndex]\n  }\n  allPositionsEqual(loc) {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] !== loc) return false\n    \n    return true\n  }\n  toString() {\n    const buf = new StringBuffer()\n    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]))\n    buf.append(Location.toLocationSymbol(this.location[Position.ON]))\n    if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]))\n    return buf.toString()\n  }\n  setLocations(on, left, right) {\n    this.location[Position.ON] = on\n    this.location[Position.LEFT] = left\n    this.location[Position.RIGHT] = right\n  }\n  isArea() {\n    return this.location.length > 1\n  }\n  isAnyNull() {\n    for (let i = 0; i < this.location.length; i++) \n      if (this.location[i] === Location.NONE) return true\n    \n    return false\n  }\n  setLocation() {\n    if (arguments.length === 1) {\n      const locValue = arguments[0]\n      this.setLocation(Position.ON, locValue)\n    } else if (arguments.length === 2) {\n      const locIndex = arguments[0], locValue = arguments[1]\n      this.location[locIndex] = locValue\n    }\n  }\n  init(size) {\n    this.location = new Array(size).fill(null)\n    this.setAllLocations(Location.NONE)\n  }\n}\n","import StringBuffer from '../../../../java/lang/StringBuffer.js'\nimport Location from '../geom/Location.js'\nimport Position from './Position.js'\nimport TopologyLocation from './TopologyLocation.js'\nexport default class Label {\n  constructor() {\n    Label.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.elt = new Array(2).fill(null)\n    if (arguments.length === 1) {\n      if (Number.isInteger(arguments[0])) {\n        const onLoc = arguments[0]\n        this.elt[0] = new TopologyLocation(onLoc)\n        this.elt[1] = new TopologyLocation(onLoc)\n      } else if (arguments[0] instanceof Label) {\n        const lbl = arguments[0]\n        this.elt[0] = new TopologyLocation(lbl.elt[0])\n        this.elt[1] = new TopologyLocation(lbl.elt[1])\n      }\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], onLoc = arguments[1]\n      this.elt[0] = new TopologyLocation(Location.NONE)\n      this.elt[1] = new TopologyLocation(Location.NONE)\n      this.elt[geomIndex].setLocation(onLoc)\n    } else if (arguments.length === 3) {\n      const onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2]\n      this.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc)\n      this.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc)\n    } else if (arguments.length === 4) {\n      const geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3]\n      this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE)\n      this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE)\n      this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc)\n    }\n  }\n  static toLineLabel(label) {\n    const lineLabel = new Label(Location.NONE)\n    for (let i = 0; i < 2; i++) \n      lineLabel.setLocation(i, label.getLocation(i))\n    \n    return lineLabel\n  }\n  getGeometryCount() {\n    let count = 0\n    if (!this.elt[0].isNull()) count++\n    if (!this.elt[1].isNull()) count++\n    return count\n  }\n  setAllLocations(geomIndex, location) {\n    this.elt[geomIndex].setAllLocations(location)\n  }\n  isNull(geomIndex) {\n    return this.elt[geomIndex].isNull()\n  }\n  setAllLocationsIfNull() {\n    if (arguments.length === 1) {\n      const location = arguments[0]\n      this.setAllLocationsIfNull(0, location)\n      this.setAllLocationsIfNull(1, location)\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], location = arguments[1]\n      this.elt[geomIndex].setAllLocationsIfNull(location)\n    }\n  }\n  isLine(geomIndex) {\n    return this.elt[geomIndex].isLine()\n  }\n  merge(lbl) {\n    for (let i = 0; i < 2; i++) \n      if (this.elt[i] === null && lbl.elt[i] !== null) \n        this.elt[i] = new TopologyLocation(lbl.elt[i])\n      else \n        this.elt[i].merge(lbl.elt[i])\n      \n    \n  }\n  flip() {\n    this.elt[0].flip()\n    this.elt[1].flip()\n  }\n  getLocation() {\n    if (arguments.length === 1) {\n      const geomIndex = arguments[0]\n      return this.elt[geomIndex].get(Position.ON)\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], posIndex = arguments[1]\n      return this.elt[geomIndex].get(posIndex)\n    }\n  }\n  toString() {\n    const buf = new StringBuffer()\n    if (this.elt[0] !== null) {\n      buf.append('A:')\n      buf.append(this.elt[0].toString())\n    }\n    if (this.elt[1] !== null) {\n      buf.append(' B:')\n      buf.append(this.elt[1].toString())\n    }\n    return buf.toString()\n  }\n  setLocation() {\n    if (arguments.length === 2) {\n      const geomIndex = arguments[0], location = arguments[1]\n      this.elt[geomIndex].setLocation(Position.ON, location)\n    } else if (arguments.length === 3) {\n      const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2]\n      this.elt[geomIndex].setLocation(posIndex, location)\n    }\n  }\n  isEqualOnSide(lbl, side) {\n    return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)\n  }\n  allPositionsEqual(geomIndex, loc) {\n    return this.elt[geomIndex].allPositionsEqual(loc)\n  }\n  toLine(geomIndex) {\n    if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0])\n  }\n  isArea() {\n    if (arguments.length === 0) {\n      return this.elt[0].isArea() || this.elt[1].isArea()\n    } else if (arguments.length === 1) {\n      const geomIndex = arguments[0]\n      return this.elt[geomIndex].isArea()\n    }\n  }\n  isAnyNull(geomIndex) {\n    return this.elt[geomIndex].isAnyNull()\n  }\n}\n","import Assert from '../util/Assert.js'\nexport default class GraphComponent {\n  constructor() {\n    GraphComponent.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._label = null\n    this._isInResult = false\n    this._isCovered = false\n    this._isCoveredSet = false\n    this._isVisited = false\n    if (arguments.length === 0) {} else if (arguments.length === 1) {\n      const label = arguments[0]\n      this._label = label\n    }\n  }\n  setVisited(isVisited) {\n    this._isVisited = isVisited\n  }\n  setInResult(isInResult) {\n    this._isInResult = isInResult\n  }\n  setLabel(label) {\n    this._label = label\n  }\n  getLabel() {\n    return this._label\n  }\n  setCovered(isCovered) {\n    this._isCovered = isCovered\n    this._isCoveredSet = true\n  }\n  updateIM(im) {\n    Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label')\n    this.computeIM(im)\n  }\n  isCovered() {\n    return this._isCovered\n  }\n  isCoveredSet() {\n    return this._isCoveredSet\n  }\n  isInResult() {\n    return this._isInResult\n  }\n  isVisited() {\n    return this._isVisited\n  }\n}\n","import Location from '../geom/Location.js'\nimport Label from './Label.js'\nimport GraphComponent from './GraphComponent.js'\nexport default class Node extends GraphComponent {\n  constructor() {\n    super()\n    Node.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._coord = null\n    this._edges = null\n    const coord = arguments[0], edges = arguments[1]\n    this._coord = coord\n    this._edges = edges\n    this._label = new Label(0, Location.NONE)\n  }\n  isIncidentEdgeInResult() {\n    for (let it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.getEdge().isInResult()) return true\n    }\n    return false\n  }\n  isIsolated() {\n    return this._label.getGeometryCount() === 1\n  }\n  getCoordinate() {\n    return this._coord\n  }\n  computeMergedLocation(label2, eltIndex) {\n    let loc = Location.NONE\n    loc = this._label.getLocation(eltIndex)\n    if (!label2.isNull(eltIndex)) {\n      const nLoc = label2.getLocation(eltIndex)\n      if (loc !== Location.BOUNDARY) loc = nLoc\n    }\n    return loc\n  }\n  setLabel() {\n    if (arguments.length === 2 && (Number.isInteger(arguments[1]) && Number.isInteger(arguments[0]))) {\n      const argIndex = arguments[0], onLocation = arguments[1]\n      if (this._label === null) \n        this._label = new Label(argIndex, onLocation)\n      else this._label.setLocation(argIndex, onLocation)\n    } else {\n      return super.setLabel.apply(this, arguments)\n    }\n  }\n  getEdges() {\n    return this._edges\n  }\n  mergeLabel() {\n    if (arguments[0] instanceof Node) {\n      const n = arguments[0]\n      this.mergeLabel(n._label)\n    } else if (arguments[0] instanceof Label) {\n      const label2 = arguments[0]\n      for (let i = 0; i < 2; i++) {\n        const loc = this.computeMergedLocation(label2, i)\n        const thisLoc = this._label.getLocation(i)\n        if (thisLoc === Location.NONE) this._label.setLocation(i, loc)\n      }\n    }\n  }\n  add(e) {\n    this._edges.insert(e)\n    e.setNode(this)\n  }\n  setLabelBoundary(argIndex) {\n    if (this._label === null) return null\n    let loc = Location.NONE\n    if (this._label !== null) loc = this._label.getLocation(argIndex)\n    let newLoc = null\n    switch (loc) {\n    case Location.BOUNDARY:\n      newLoc = Location.INTERIOR\n      break\n    case Location.INTERIOR:\n      newLoc = Location.BOUNDARY\n      break\n    default:\n      newLoc = Location.BOUNDARY\n      break\n    }\n    this._label.setLocation(argIndex, newLoc)\n  }\n  print(out) {\n    out.println('node ' + this._coord + ' lbl: ' + this._label)\n  }\n  computeIM(im) {}\n}\n","import Location from '../geom/Location.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Node from './Node.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport TreeMap from '../../../../java/util/TreeMap.js'\nexport default class NodeMap {\n  constructor() {\n    NodeMap.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.nodeMap = new TreeMap()\n    this.nodeFact = null\n    const nodeFact = arguments[0]\n    this.nodeFact = nodeFact\n  }\n  print(out) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const n = it.next()\n      n.print(out)\n    }\n  }\n  iterator() {\n    return this.nodeMap.values().iterator()\n  }\n  values() {\n    return this.nodeMap.values()\n  }\n  getBoundaryNodes(geomIndex) {\n    const bdyNodes = new ArrayList()\n    for (let i = this.iterator(); i.hasNext(); ) {\n      const node = i.next()\n      if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node)\n    }\n    return bdyNodes\n  }\n  add(e) {\n    const p = e.getCoordinate()\n    const n = this.addNode(p)\n    n.add(e)\n  }\n  find(coord) {\n    return this.nodeMap.get(coord)\n  }\n  addNode() {\n    if (arguments[0] instanceof Coordinate) {\n      const coord = arguments[0]\n      let node = this.nodeMap.get(coord)\n      if (node === null) {\n        node = this.nodeFact.createNode(coord)\n        this.nodeMap.put(coord, node)\n      }\n      return node\n    } else if (arguments[0] instanceof Node) {\n      const n = arguments[0]\n      const node = this.nodeMap.get(n.getCoordinate())\n      if (node === null) {\n        this.nodeMap.put(n.getCoordinate(), n)\n        return n\n      }\n      node.mergeLabel(n)\n      return node\n    }\n  }\n}\n","import Node from './Node.js'\nexport default class NodeFactory {\n  createNode(coord) {\n    return new Node(coord, null)\n  }\n}\n","import Orientation from '../algorithm/Orientation.js'\nimport Comparable from '../../../../java/lang/Comparable.js'\nimport Quadrant from './Quadrant.js'\nimport Assert from '../util/Assert.js'\nexport default class EdgeEnd {\n  constructor() {\n    EdgeEnd.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edge = null\n    this._label = null\n    this._node = null\n    this._p0 = null\n    this._p1 = null\n    this._dx = null\n    this._dy = null\n    this._quadrant = null\n    if (arguments.length === 1) {\n      const edge = arguments[0]\n      this._edge = edge\n    } else if (arguments.length === 3) {\n      const edge = arguments[0], p0 = arguments[1], p1 = arguments[2]\n      EdgeEnd.constructor_.call(this, edge, p0, p1, null)\n    } else if (arguments.length === 4) {\n      const edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3]\n      EdgeEnd.constructor_.call(this, edge)\n      this.init(p0, p1)\n      this._label = label\n    }\n  }\n  compareDirection(e) {\n    if (this._dx === e._dx && this._dy === e._dy) return 0\n    if (this._quadrant > e._quadrant) return 1\n    if (this._quadrant < e._quadrant) return -1\n    return Orientation.index(e._p0, e._p1, this._p1)\n  }\n  getDy() {\n    return this._dy\n  }\n  print(out) {\n    const angle = Math.atan2(this._dy, this._dx)\n    const className = this.getClass().getName()\n    const lastDotPos = className.lastIndexOf('.')\n    const name = className.substring(lastDotPos + 1)\n    out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label)\n  }\n  getLabel() {\n    return this._label\n  }\n  getEdge() {\n    return this._edge\n  }\n  toString() {\n    const angle = Math.atan2(this._dy, this._dx)\n    const className = this.getClass().getName()\n    const lastDotPos = className.lastIndexOf('.')\n    const name = className.substring(lastDotPos + 1)\n    return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label\n  }\n  computeLabel(boundaryNodeRule) {}\n  init(p0, p1) {\n    this._p0 = p0\n    this._p1 = p1\n    this._dx = p1.x - p0.x\n    this._dy = p1.y - p0.y\n    this._quadrant = Quadrant.quadrant(this._dx, this._dy)\n    Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found')\n  }\n  getCoordinate() {\n    return this._p0\n  }\n  setNode(node) {\n    this._node = node\n  }\n  compareTo(obj) {\n    const e = obj\n    return this.compareDirection(e)\n  }\n  getDirectedCoordinate() {\n    return this._p1\n  }\n  getDx() {\n    return this._dx\n  }\n  getQuadrant() {\n    return this._quadrant\n  }\n  getNode() {\n    return this._node\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import Location from '../geom/Location.js'\nimport EdgeEnd from './EdgeEnd.js'\nimport Position from './Position.js'\nimport TopologyException from '../geom/TopologyException.js'\nimport Label from './Label.js'\nexport default class DirectedEdge extends EdgeEnd {\n  constructor() {\n    super()\n    DirectedEdge.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._isForward = null\n    this._isInResult = false\n    this._isVisited = false\n    this._sym = null\n    this._next = null\n    this._nextMin = null\n    this._edgeRing = null\n    this._minEdgeRing = null\n    this._depth = [0, -999, -999]\n    const edge = arguments[0], isForward = arguments[1]\n    EdgeEnd.constructor_.call(this, edge)\n    this._isForward = isForward\n    if (isForward) {\n      this.init(edge.getCoordinate(0), edge.getCoordinate(1))\n    } else {\n      const n = edge.getNumPoints() - 1\n      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1))\n    }\n    this.computeDirectedLabel()\n  }\n  static depthFactor(currLocation, nextLocation) {\n    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1\n    return 0\n  }\n  setVisited(isVisited) {\n    this._isVisited = isVisited\n  }\n  setDepth(position, depthVal) {\n    if (this._depth[position] !== -999) \n      if (this._depth[position] !== depthVal) throw new TopologyException('assigned depths do not match', this.getCoordinate())\n    \n    this._depth[position] = depthVal\n  }\n  isInteriorAreaEdge() {\n    let isInteriorAreaEdge = true\n    for (let i = 0; i < 2; i++) \n      if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) \n        isInteriorAreaEdge = false\n      \n    \n    return isInteriorAreaEdge\n  }\n  setNextMin(nextMin) {\n    this._nextMin = nextMin\n  }\n  print(out) {\n    super.print.call(this, out)\n    out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT])\n    out.print(' (' + this.getDepthDelta() + ')')\n    if (this._isInResult) out.print(' inResult')\n  }\n  setMinEdgeRing(minEdgeRing) {\n    this._minEdgeRing = minEdgeRing\n  }\n  getSym() {\n    return this._sym\n  }\n  isForward() {\n    return this._isForward\n  }\n  setSym(de) {\n    this._sym = de\n  }\n  setVisitedEdge(isVisited) {\n    this.setVisited(isVisited)\n    this._sym.setVisited(isVisited)\n  }\n  getNextMin() {\n    return this._nextMin\n  }\n  getDepth(position) {\n    return this._depth[position]\n  }\n  computeDirectedLabel() {\n    this._label = new Label(this._edge.getLabel())\n    if (!this._isForward) this._label.flip()\n  }\n  getNext() {\n    return this._next\n  }\n  isLineEdge() {\n    const isLine = this._label.isLine(0) || this._label.isLine(1)\n    const isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR)\n    const isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR)\n    return isLine && isExteriorIfArea0 && isExteriorIfArea1\n  }\n  setEdgeRing(edgeRing) {\n    this._edgeRing = edgeRing\n  }\n  getMinEdgeRing() {\n    return this._minEdgeRing\n  }\n  getDepthDelta() {\n    let depthDelta = this._edge.getDepthDelta()\n    if (!this._isForward) depthDelta = -depthDelta\n    return depthDelta\n  }\n  setInResult(isInResult) {\n    this._isInResult = isInResult\n  }\n  getEdge() {\n    return this._edge\n  }\n  printEdge(out) {\n    this.print(out)\n    out.print(' ')\n    if (this._isForward) this._edge.print(out); else this._edge.printReverse(out)\n  }\n  setEdgeDepths(position, depth) {\n    let depthDelta = this.getEdge().getDepthDelta()\n    if (!this._isForward) depthDelta = -depthDelta\n    let directionFactor = 1\n    if (position === Position.LEFT) directionFactor = -1\n    const oppositePos = Position.opposite(position)\n    const delta = depthDelta * directionFactor\n    const oppositeDepth = depth + delta\n    this.setDepth(position, depth)\n    this.setDepth(oppositePos, oppositeDepth)\n  }\n  getEdgeRing() {\n    return this._edgeRing\n  }\n  isInResult() {\n    return this._isInResult\n  }\n  setNext(next) {\n    this._next = next\n  }\n  isVisited() {\n    return this._isVisited\n  }\n}\n","import Location from '../geom/Location.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Node from './Node.js'\nimport NodeMap from './NodeMap.js'\nimport System from '../../../../java/lang/System.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport Quadrant from './Quadrant.js'\nimport NodeFactory from './NodeFactory.js'\nimport Orientation from '../algorithm/Orientation.js'\nimport DirectedEdge from './DirectedEdge.js'\nexport default class PlanarGraph {\n  constructor() {\n    PlanarGraph.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edges = new ArrayList()\n    this._nodes = null\n    this._edgeEndList = new ArrayList()\n    if (arguments.length === 0) {\n      this._nodes = new NodeMap(new NodeFactory())\n    } else if (arguments.length === 1) {\n      const nodeFact = arguments[0]\n      this._nodes = new NodeMap(nodeFact)\n    }\n  }\n  static linkResultDirectedEdges(nodes) {\n    for (let nodeit = nodes.iterator(); nodeit.hasNext(); ) {\n      const node = nodeit.next()\n      node.getEdges().linkResultDirectedEdges()\n    }\n  }\n  printEdges(out) {\n    out.println('Edges:')\n    for (let i = 0; i < this._edges.size(); i++) {\n      out.println('edge ' + i + ':')\n      const e = this._edges.get(i)\n      e.print(out)\n      e.eiList.print(out)\n    }\n  }\n  debugPrintln(o) {\n    System.out.println(o)\n  }\n  isBoundaryNode(geomIndex, coord) {\n    const node = this._nodes.find(coord)\n    if (node === null) return false\n    const label = node.getLabel()\n    if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true\n    return false\n  }\n  linkAllDirectedEdges() {\n    for (let nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n      const node = nodeit.next()\n      node.getEdges().linkAllDirectedEdges()\n    }\n  }\n  debugPrint(o) {\n    System.out.print(o)\n  }\n  findEdgeEnd(e) {\n    for (let i = this.getEdgeEnds().iterator(); i.hasNext(); ) {\n      const ee = i.next()\n      if (ee.getEdge() === e) return ee\n    }\n    return null\n  }\n  getNodes() {\n    return this._nodes.values()\n  }\n  findEdge(p0, p1) {\n    for (let i = 0; i < this._edges.size(); i++) {\n      const e = this._edges.get(i)\n      const eCoord = e.getCoordinates()\n      if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e\n    }\n    return null\n  }\n  find(coord) {\n    return this._nodes.find(coord)\n  }\n  addNode() {\n    if (arguments[0] instanceof Node) {\n      const node = arguments[0]\n      return this._nodes.addNode(node)\n    } else if (arguments[0] instanceof Coordinate) {\n      const coord = arguments[0]\n      return this._nodes.addNode(coord)\n    }\n  }\n  getNodeIterator() {\n    return this._nodes.iterator()\n  }\n  linkResultDirectedEdges() {\n    for (let nodeit = this._nodes.iterator(); nodeit.hasNext(); ) {\n      const node = nodeit.next()\n      node.getEdges().linkResultDirectedEdges()\n    }\n  }\n  matchInSameDirection(p0, p1, ep0, ep1) {\n    if (!p0.equals(ep0)) return false\n    if (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true\n    return false\n  }\n  getEdgeEnds() {\n    return this._edgeEndList\n  }\n  getEdgeIterator() {\n    return this._edges.iterator()\n  }\n  findEdgeInSameDirection(p0, p1) {\n    for (let i = 0; i < this._edges.size(); i++) {\n      const e = this._edges.get(i)\n      const eCoord = e.getCoordinates()\n      if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e\n      if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e\n    }\n    return null\n  }\n  insertEdge(e) {\n    this._edges.add(e)\n  }\n  addEdges(edgesToAdd) {\n    for (let it = edgesToAdd.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      this._edges.add(e)\n      const de1 = new DirectedEdge(e, true)\n      const de2 = new DirectedEdge(e, false)\n      de1.setSym(de2)\n      de2.setSym(de1)\n      this.add(de1)\n      this.add(de2)\n    }\n  }\n  add(e) {\n    this._nodes.add(e)\n    this._edgeEndList.add(e)\n  }\n}\n","import Location from '../geom/Location.js'\nimport hasInterface from '../../../../hasInterface.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Orientation from './Orientation.js'\nimport CoordinateSequence from '../geom/CoordinateSequence.js'\nexport default class RayCrossingCounter {\n  constructor() {\n    RayCrossingCounter.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._p = null\n    this._crossingCount = 0\n    this._isPointOnSegment = false\n    const p = arguments[0]\n    this._p = p\n  }\n  static locatePointInRing() {\n    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n      const p = arguments[0], ring = arguments[1]\n      const counter = new RayCrossingCounter(p)\n      const p1 = new Coordinate()\n      const p2 = new Coordinate()\n      for (let i = 1; i < ring.size(); i++) {\n        ring.getCoordinate(i, p1)\n        ring.getCoordinate(i - 1, p2)\n        counter.countSegment(p1, p2)\n        if (counter.isOnSegment()) return counter.getLocation()\n      }\n      return counter.getLocation()\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n      const p = arguments[0], ring = arguments[1]\n      const counter = new RayCrossingCounter(p)\n      for (let i = 1; i < ring.length; i++) {\n        const p1 = ring[i]\n        const p2 = ring[i - 1]\n        counter.countSegment(p1, p2)\n        if (counter.isOnSegment()) return counter.getLocation()\n      }\n      return counter.getLocation()\n    }\n  }\n  getLocation() {\n    if (this._isPointOnSegment) return Location.BOUNDARY\n    if (this._crossingCount % 2 === 1) \n      return Location.INTERIOR\n    \n    return Location.EXTERIOR\n  }\n  isPointInPolygon() {\n    return this.getLocation() !== Location.EXTERIOR\n  }\n  isOnSegment() {\n    return this._isPointOnSegment\n  }\n  countSegment(p1, p2) {\n    if (p1.x < this._p.x && p2.x < this._p.x) return null\n    if (this._p.x === p2.x && this._p.y === p2.y) {\n      this._isPointOnSegment = true\n      return null\n    }\n    if (p1.y === this._p.y && p2.y === this._p.y) {\n      let minx = p1.x\n      let maxx = p2.x\n      if (minx > maxx) {\n        minx = p2.x\n        maxx = p1.x\n      }\n      if (this._p.x >= minx && this._p.x <= maxx) \n        this._isPointOnSegment = true\n      \n      return null\n    }\n    if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n      let orient = Orientation.index(p1, p2, this._p)\n      if (orient === Orientation.COLLINEAR) {\n        this._isPointOnSegment = true\n        return null\n      }\n      if (p2.y < p1.y) \n        orient = -orient\n      \n      if (orient === Orientation.LEFT) \n        this._crossingCount++\n      \n    }\n  }\n}\n","import Location from '../geom/Location.js'\nimport hasInterface from '../../../../hasInterface.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport CoordinateSequence from '../geom/CoordinateSequence.js'\nimport RobustLineIntersector from './RobustLineIntersector.js'\nimport RayCrossingCounter from './RayCrossingCounter.js'\nexport default class PointLocation {\n  static isInRing(p, ring) {\n    return PointLocation.locateInRing(p, ring) !== Location.EXTERIOR\n  }\n  static locateInRing(p, ring) {\n    return RayCrossingCounter.locatePointInRing(p, ring)\n  }\n  static isOnLine() {\n    if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n      const p = arguments[0], line = arguments[1]\n      const lineIntersector = new RobustLineIntersector()\n      const p0 = new Coordinate()\n      const p1 = new Coordinate()\n      const n = line.size()\n      for (let i = 1; i < n; i++) {\n        line.getCoordinate(i - 1, p0)\n        line.getCoordinate(i, p1)\n        lineIntersector.computeIntersection(p, p0, p1)\n        if (lineIntersector.hasIntersection()) \n          return true\n        \n      }\n      return false\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n      const p = arguments[0], line = arguments[1]\n      const lineIntersector = new RobustLineIntersector()\n      for (let i = 1; i < line.length; i++) {\n        const p0 = line[i - 1]\n        const p1 = line[i]\n        lineIntersector.computeIntersection(p, p0, p1)\n        if (lineIntersector.hasIntersection()) \n          return true\n        \n      }\n      return false\n    }\n  }\n}\n","import Location from '../geom/Location.js'\nimport Position from './Position.js'\nimport PointLocation from '../algorithm/PointLocation.js'\nimport TopologyException from '../geom/TopologyException.js'\nimport Orientation from '../algorithm/Orientation.js'\nimport Label from './Label.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport Assert from '../util/Assert.js'\nexport default class EdgeRing {\n  constructor() {\n    EdgeRing.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._startDe = null\n    this._maxNodeDegree = -1\n    this._edges = new ArrayList()\n    this._pts = new ArrayList()\n    this._label = new Label(Location.NONE)\n    this._ring = null\n    this._isHole = null\n    this._shell = null\n    this._holes = new ArrayList()\n    this._geometryFactory = null\n    if (arguments.length === 0) {} else if (arguments.length === 2) {\n      const start = arguments[0], geometryFactory = arguments[1]\n      this._geometryFactory = geometryFactory\n      this.computePoints(start)\n      this.computeRing()\n    }\n  }\n  computeRing() {\n    if (this._ring !== null) return null\n    const coord = new Array(this._pts.size()).fill(null)\n    for (let i = 0; i < this._pts.size(); i++) \n      coord[i] = this._pts.get(i)\n    \n    this._ring = this._geometryFactory.createLinearRing(coord)\n    this._isHole = Orientation.isCCW(this._ring.getCoordinates())\n  }\n  isIsolated() {\n    return this._label.getGeometryCount() === 1\n  }\n  computePoints(start) {\n    this._startDe = start\n    let de = start\n    let isFirstEdge = true\n    do {\n      if (de === null) throw new TopologyException('Found null DirectedEdge')\n      if (de.getEdgeRing() === this) throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate())\n      this._edges.add(de)\n      const label = de.getLabel()\n      Assert.isTrue(label.isArea())\n      this.mergeLabel(label)\n      this.addPoints(de.getEdge(), de.isForward(), isFirstEdge)\n      isFirstEdge = false\n      this.setEdgeRing(de, this)\n      de = this.getNext(de)\n    } while (de !== this._startDe)\n  }\n  getLinearRing() {\n    return this._ring\n  }\n  getCoordinate(i) {\n    return this._pts.get(i)\n  }\n  computeMaxNodeDegree() {\n    this._maxNodeDegree = 0\n    let de = this._startDe\n    do {\n      const node = de.getNode()\n      const degree = node.getEdges().getOutgoingDegree(this)\n      if (degree > this._maxNodeDegree) this._maxNodeDegree = degree\n      de = this.getNext(de)\n    } while (de !== this._startDe)\n    this._maxNodeDegree *= 2\n  }\n  addPoints(edge, isForward, isFirstEdge) {\n    const edgePts = edge.getCoordinates()\n    if (isForward) {\n      let startIndex = 1\n      if (isFirstEdge) startIndex = 0\n      for (let i = startIndex; i < edgePts.length; i++) \n        this._pts.add(edgePts[i])\n      \n    } else {\n      let startIndex = edgePts.length - 2\n      if (isFirstEdge) startIndex = edgePts.length - 1\n      for (let i = startIndex; i >= 0; i--) \n        this._pts.add(edgePts[i])\n      \n    }\n  }\n  containsPoint(p) {\n    const shell = this.getLinearRing()\n    const env = shell.getEnvelopeInternal()\n    if (!env.contains(p)) return false\n    if (!PointLocation.isInRing(p, shell.getCoordinates())) return false\n    for (let i = this._holes.iterator(); i.hasNext(); ) {\n      const hole = i.next()\n      if (hole.containsPoint(p)) return false\n    }\n    return true\n  }\n  getMaxNodeDegree() {\n    if (this._maxNodeDegree < 0) this.computeMaxNodeDegree()\n    return this._maxNodeDegree\n  }\n  setShell(shell) {\n    this._shell = shell\n    if (shell !== null) shell.addHole(this)\n  }\n  toPolygon(geometryFactory) {\n    const holeLR = new Array(this._holes.size()).fill(null)\n    for (let i = 0; i < this._holes.size(); i++) \n      holeLR[i] = this._holes.get(i).getLinearRing()\n    \n    const poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR)\n    return poly\n  }\n  isHole() {\n    return this._isHole\n  }\n  setInResult() {\n    let de = this._startDe\n    do {\n      de.getEdge().setInResult(true)\n      de = de.getNext()\n    } while (de !== this._startDe)\n  }\n  addHole(ring) {\n    this._holes.add(ring)\n  }\n  isShell() {\n    return this._shell === null\n  }\n  getLabel() {\n    return this._label\n  }\n  getEdges() {\n    return this._edges\n  }\n  getShell() {\n    return this._shell\n  }\n  mergeLabel() {\n    if (arguments.length === 1) {\n      const deLabel = arguments[0]\n      this.mergeLabel(deLabel, 0)\n      this.mergeLabel(deLabel, 1)\n    } else if (arguments.length === 2) {\n      const deLabel = arguments[0], geomIndex = arguments[1]\n      const loc = deLabel.getLocation(geomIndex, Position.RIGHT)\n      if (loc === Location.NONE) return null\n      if (this._label.getLocation(geomIndex) === Location.NONE) {\n        this._label.setLocation(geomIndex, loc)\n        return null\n      }\n    }\n  }\n}\n","import EdgeRing from '../../geomgraph/EdgeRing.js'\nexport default class MinimalEdgeRing extends EdgeRing {\n  constructor() {\n    super()\n    MinimalEdgeRing.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const start = arguments[0], geometryFactory = arguments[1]\n    EdgeRing.constructor_.call(this, start, geometryFactory)\n  }\n  getNext(de) {\n    return de.getNextMin()\n  }\n  setEdgeRing(de, er) {\n    de.setMinEdgeRing(er)\n  }\n}\n","import MinimalEdgeRing from './MinimalEdgeRing.js'\nimport EdgeRing from '../../geomgraph/EdgeRing.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nexport default class MaximalEdgeRing extends EdgeRing {\n  constructor() {\n    super()\n    MaximalEdgeRing.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    const start = arguments[0], geometryFactory = arguments[1]\n    EdgeRing.constructor_.call(this, start, geometryFactory)\n  }\n  linkDirectedEdgesForMinimalEdgeRings() {\n    let de = this._startDe\n    do {\n      const node = de.getNode()\n      node.getEdges().linkMinimalDirectedEdges(this)\n      de = de.getNext()\n    } while (de !== this._startDe)\n  }\n  buildMinimalRings() {\n    const minEdgeRings = new ArrayList()\n    let de = this._startDe\n    do {\n      if (de.getMinEdgeRing() === null) {\n        const minEr = new MinimalEdgeRing(de, this._geometryFactory)\n        minEdgeRings.add(minEr)\n      }\n      de = de.getNext()\n    } while (de !== this._startDe)\n    return minEdgeRings\n  }\n  getNext(de) {\n    return de.getNext()\n  }\n  setEdgeRing(de, er) {\n    de.setEdgeRing(er)\n  }\n}\n","import PointLocation from '../../algorithm/PointLocation.js'\nimport TopologyException from '../../geom/TopologyException.js'\nimport MaximalEdgeRing from './MaximalEdgeRing.js'\nimport CoordinateArrays from '../../geom/CoordinateArrays.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Assert from '../../util/Assert.js'\nimport PlanarGraph from '../../geomgraph/PlanarGraph.js'\nexport default class PolygonBuilder {\n  constructor() {\n    PolygonBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._geometryFactory = null\n    this._shellList = new ArrayList()\n    const geometryFactory = arguments[0]\n    this._geometryFactory = geometryFactory\n  }\n  static findEdgeRingContaining(testEr, shellList) {\n    const testRing = testEr.getLinearRing()\n    const testEnv = testRing.getEnvelopeInternal()\n    let testPt = testRing.getCoordinateN(0)\n    let minShell = null\n    let minShellEnv = null\n    for (let it = shellList.iterator(); it.hasNext(); ) {\n      const tryShell = it.next()\n      const tryShellRing = tryShell.getLinearRing()\n      const tryShellEnv = tryShellRing.getEnvelopeInternal()\n      if (tryShellEnv.equals(testEnv)) continue\n      if (!tryShellEnv.contains(testEnv)) continue\n      testPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates())\n      let isContained = false\n      if (PointLocation.isInRing(testPt, tryShellRing.getCoordinates())) isContained = true\n      if (isContained) \n        if (minShell === null || minShellEnv.contains(tryShellEnv)) {\n          minShell = tryShell\n          minShellEnv = minShell.getLinearRing().getEnvelopeInternal()\n        }\n      \n    }\n    return minShell\n  }\n  sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n    for (let it = edgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (er.isHole()) \n        freeHoleList.add(er)\n      else \n        shellList.add(er)\n      \n    }\n  }\n  computePolygons(shellList) {\n    const resultPolyList = new ArrayList()\n    for (let it = shellList.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      const poly = er.toPolygon(this._geometryFactory)\n      resultPolyList.add(poly)\n    }\n    return resultPolyList\n  }\n  placeFreeHoles(shellList, freeHoleList) {\n    for (let it = freeHoleList.iterator(); it.hasNext(); ) {\n      const hole = it.next()\n      if (hole.getShell() === null) {\n        const shell = PolygonBuilder.findEdgeRingContaining(hole, shellList)\n        if (shell === null) throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0))\n        hole.setShell(shell)\n      }\n    }\n  }\n  buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n    const edgeRings = new ArrayList()\n    for (let it = maxEdgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (er.getMaxNodeDegree() > 2) {\n        er.linkDirectedEdgesForMinimalEdgeRings()\n        const minEdgeRings = er.buildMinimalRings()\n        const shell = this.findShell(minEdgeRings)\n        if (shell !== null) {\n          this.placePolygonHoles(shell, minEdgeRings)\n          shellList.add(shell)\n        } else {\n          freeHoleList.addAll(minEdgeRings)\n        }\n      } else {\n        edgeRings.add(er)\n      }\n    }\n    return edgeRings\n  }\n  buildMaximalEdgeRings(dirEdges) {\n    const maxEdgeRings = new ArrayList()\n    for (let it = dirEdges.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.isInResult() && de.getLabel().isArea()) \n        if (de.getEdgeRing() === null) {\n          const er = new MaximalEdgeRing(de, this._geometryFactory)\n          maxEdgeRings.add(er)\n          er.setInResult()\n        }\n      \n    }\n    return maxEdgeRings\n  }\n  placePolygonHoles(shell, minEdgeRings) {\n    for (let it = minEdgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (er.isHole()) \n        er.setShell(shell)\n      \n    }\n  }\n  getPolygons() {\n    const resultPolyList = this.computePolygons(this._shellList)\n    return resultPolyList\n  }\n  findShell(minEdgeRings) {\n    let shellCount = 0\n    let shell = null\n    for (let it = minEdgeRings.iterator(); it.hasNext(); ) {\n      const er = it.next()\n      if (!er.isHole()) {\n        shell = er\n        shellCount++\n      }\n    }\n    Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list')\n    return shell\n  }\n  add() {\n    if (arguments.length === 1) {\n      const graph = arguments[0]\n      this.add(graph.getEdgeEnds(), graph.getNodes())\n    } else if (arguments.length === 2) {\n      const dirEdges = arguments[0], nodes = arguments[1]\n      PlanarGraph.linkResultDirectedEdges(nodes)\n      const maxEdgeRings = this.buildMaximalEdgeRings(dirEdges)\n      const freeHoleList = new ArrayList()\n      const edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList)\n      this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList)\n      this.placeFreeHoles(this._shellList, freeHoleList)\n    }\n  }\n}\n","import hasInterface from '../../../../../hasInterface.js'\nimport Position from '../../geomgraph/Position.js'\nimport Coordinate from '../../geom/Coordinate.js'\nimport LineSegment from '../../geom/LineSegment.js'\nimport Comparable from '../../../../../java/lang/Comparable.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport List from '../../../../../java/util/List.js'\nimport DirectedEdge from '../../geomgraph/DirectedEdge.js'\nimport Orientation from '../../algorithm/Orientation.js'\nimport Collections from '../../../../../java/util/Collections.js'\nexport default class SubgraphDepthLocater {\n  constructor() {\n    SubgraphDepthLocater.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._subgraphs = null\n    this._seg = new LineSegment()\n    const subgraphs = arguments[0]\n    this._subgraphs = subgraphs\n  }\n  findStabbedSegments() {\n    if (arguments.length === 1) {\n      const stabbingRayLeftPt = arguments[0]\n      const stabbedSegments = new ArrayList()\n      for (let i = this._subgraphs.iterator(); i.hasNext(); ) {\n        const bsg = i.next()\n        const env = bsg.getEnvelope()\n        if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue\n        this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments)\n      }\n      return stabbedSegments\n    } else if (arguments.length === 3) {\n      if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {\n        const stabbingRayLeftPt = arguments[0], dirEdge = arguments[1], stabbedSegments = arguments[2]\n        const pts = dirEdge.getEdge().getCoordinates()\n        for (let i = 0; i < pts.length - 1; i++) {\n          this._seg.p0 = pts[i]\n          this._seg.p1 = pts[i + 1]\n          if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse()\n          const maxx = Math.max(this._seg.p0.x, this._seg.p1.x)\n          if (maxx < stabbingRayLeftPt.x) continue\n          if (this._seg.isHorizontal()) continue\n          if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue\n          if (Orientation.index(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === Orientation.RIGHT) continue\n          let depth = dirEdge.getDepth(Position.LEFT)\n          if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT)\n          const ds = new DepthSegment(this._seg, depth)\n          stabbedSegments.add(ds)\n        }\n      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {\n        const stabbingRayLeftPt = arguments[0], dirEdges = arguments[1], stabbedSegments = arguments[2]\n        for (let i = dirEdges.iterator(); i.hasNext(); ) {\n          const de = i.next()\n          if (!de.isForward()) continue\n          this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments)\n        }\n      }\n    }\n  }\n  getDepth(p) {\n    const stabbedSegments = this.findStabbedSegments(p)\n    if (stabbedSegments.size() === 0) return 0\n    const ds = Collections.min(stabbedSegments)\n    return ds._leftDepth\n  }\n}\nclass DepthSegment {\n  constructor() {\n    DepthSegment.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._upwardSeg = null\n    this._leftDepth = null\n    const seg = arguments[0], depth = arguments[1]\n    this._upwardSeg = new LineSegment(seg)\n    this._leftDepth = depth\n  }\n  compareX(seg0, seg1) {\n    const compare0 = seg0.p0.compareTo(seg1.p0)\n    if (compare0 !== 0) return compare0\n    return seg0.p1.compareTo(seg1.p1)\n  }\n  toString() {\n    return this._upwardSeg.toString()\n  }\n  compareTo(obj) {\n    const other = obj\n    if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1\n    if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1\n    let orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg)\n    if (orientIndex !== 0) return orientIndex\n    orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg)\n    if (orientIndex !== 0) return orientIndex\n    return this._upwardSeg.compareTo(other._upwardSeg)\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\nSubgraphDepthLocater.DepthSegment = DepthSegment\n","import Exception from '../../../../java/lang/Exception.js'\nexport default class NotRepresentableException extends Exception {\n  constructor() {\n    super()\n    NotRepresentableException.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    Exception.constructor_.call(this, 'Projective point not representable on the Cartesian plane.')\n  }\n}\n","import NotRepresentableException from './NotRepresentableException.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Double from '../../../../java/lang/Double.js'\nexport default class HCoordinate {\n  constructor() {\n    HCoordinate.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.x = null\n    this.y = null\n    this.w = null\n    if (arguments.length === 0) {\n      this.x = 0.0\n      this.y = 0.0\n      this.w = 1.0\n    } else if (arguments.length === 1) {\n      const p = arguments[0]\n      this.x = p.x\n      this.y = p.y\n      this.w = 1.0\n    } else if (arguments.length === 2) {\n      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const _x = arguments[0], _y = arguments[1]\n        this.x = _x\n        this.y = _y\n        this.w = 1.0\n      } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n        const p1 = arguments[0], p2 = arguments[1]\n        this.x = p1.y * p2.w - p2.y * p1.w\n        this.y = p2.x * p1.w - p1.x * p2.w\n        this.w = p1.x * p2.y - p2.x * p1.y\n      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        const p1 = arguments[0], p2 = arguments[1]\n        this.x = p1.y - p2.y\n        this.y = p2.x - p1.x\n        this.w = p1.x * p2.y - p2.x * p1.y\n      }\n    } else if (arguments.length === 3) {\n      const _x = arguments[0], _y = arguments[1], _w = arguments[2]\n      this.x = _x\n      this.y = _y\n      this.w = _w\n    } else if (arguments.length === 4) {\n      const p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3]\n      const px = p1.y - p2.y\n      const py = p2.x - p1.x\n      const pw = p1.x * p2.y - p2.x * p1.y\n      const qx = q1.y - q2.y\n      const qy = q2.x - q1.x\n      const qw = q1.x * q2.y - q2.x * q1.y\n      this.x = py * qw - qy * pw\n      this.y = qx * pw - px * qw\n      this.w = px * qy - qx * py\n    }\n  }\n  getCoordinate() {\n    const p = new Coordinate()\n    p.x = this.getX()\n    p.y = this.getY()\n    return p\n  }\n  getX() {\n    const a = this.x / this.w\n    if (Double.isNaN(a) || Double.isInfinite(a)) \n      throw new NotRepresentableException()\n    \n    return a\n  }\n  getY() {\n    const a = this.y / this.w\n    if (Double.isNaN(a) || Double.isInfinite(a)) \n      throw new NotRepresentableException()\n    \n    return a\n  }\n}\n","import DD from '../math/DD.js'\nimport Angle from '../algorithm/Angle.js'\nimport HCoordinate from '../algorithm/HCoordinate.js'\nimport Coordinate from './Coordinate.js'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException.js'\nexport default class Triangle {\n  constructor() {\n    Triangle.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.p0 = null\n    this.p1 = null\n    this.p2 = null\n    const p0 = arguments[0], p1 = arguments[1], p2 = arguments[2]\n    this.p0 = p0\n    this.p1 = p1\n    this.p2 = p2\n  }\n  static isAcute(a, b, c) {\n    if (!Angle.isAcute(a, b, c)) return false\n    if (!Angle.isAcute(b, c, a)) return false\n    if (!Angle.isAcute(c, a, b)) return false\n    return true\n  }\n  static circumcentre(a, b, c) {\n    const cx = c.x\n    const cy = c.y\n    const ax = a.x - cx\n    const ay = a.y - cy\n    const bx = b.x - cx\n    const by = b.y - cy\n    const denom = 2 * Triangle.det(ax, ay, bx, by)\n    const numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by)\n    const numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by)\n    const ccx = cx - numx / denom\n    const ccy = cy + numy / denom\n    return new Coordinate(ccx, ccy)\n  }\n  static perpendicularBisector(a, b) {\n    const dx = b.x - a.x\n    const dy = b.y - a.y\n    const l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0)\n    const l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0)\n    return new HCoordinate(l1, l2)\n  }\n  static angleBisector(a, b, c) {\n    const len0 = b.distance(a)\n    const len2 = b.distance(c)\n    const frac = len0 / (len0 + len2)\n    const dx = c.x - a.x\n    const dy = c.y - a.y\n    const splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy)\n    return splitPt\n  }\n  static inCentre(a, b, c) {\n    const len0 = b.distance(c)\n    const len1 = a.distance(c)\n    const len2 = a.distance(b)\n    const circum = len0 + len1 + len2\n    const inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum\n    const inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum\n    return new Coordinate(inCentreX, inCentreY)\n  }\n  static area(a, b, c) {\n    return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)\n  }\n  static signedArea(a, b, c) {\n    return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2\n  }\n  static det(m00, m01, m10, m11) {\n    return m00 * m11 - m01 * m10\n  }\n  static interpolateZ(p, v0, v1, v2) {\n    const x0 = v0.x\n    const y0 = v0.y\n    const a = v1.x - x0\n    const b = v2.x - x0\n    const c = v1.y - y0\n    const d = v2.y - y0\n    const det = a * d - b * c\n    const dx = p.x - x0\n    const dy = p.y - y0\n    const t = (d * dx - b * dy) / det\n    const u = (-c * dx + a * dy) / det\n    const z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ())\n    return z\n  }\n  static longestSideLength(a, b, c) {\n    const lenAB = a.distance(b)\n    const lenBC = b.distance(c)\n    const lenCA = c.distance(a)\n    let maxLen = lenAB\n    if (lenBC > maxLen) maxLen = lenBC\n    if (lenCA > maxLen) maxLen = lenCA\n    return maxLen\n  }\n  static circumcentreDD(a, b, c) {\n    const ax = DD.valueOf(a.x).subtract(c.x)\n    const ay = DD.valueOf(a.y).subtract(c.y)\n    const bx = DD.valueOf(b.x).subtract(c.x)\n    const by = DD.valueOf(b.y).subtract(c.y)\n    const denom = DD.determinant(ax, ay, bx, by).multiply(2)\n    const asqr = ax.sqr().add(ay.sqr())\n    const bsqr = bx.sqr().add(by.sqr())\n    const numx = DD.determinant(ay, asqr, by, bsqr)\n    const numy = DD.determinant(ax, asqr, bx, bsqr)\n    const ccx = DD.valueOf(c.x).subtract(numx.divide(denom)).doubleValue()\n    const ccy = DD.valueOf(c.y).add(numy.divide(denom)).doubleValue()\n    return new Coordinate(ccx, ccy)\n  }\n  static area3D(a, b, c) {\n    const ux = b.x - a.x\n    const uy = b.y - a.y\n    const uz = b.getZ() - a.getZ()\n    const vx = c.x - a.x\n    const vy = c.y - a.y\n    const vz = c.getZ() - a.getZ()\n    const crossx = uy * vz - uz * vy\n    const crossy = uz * vx - ux * vz\n    const crossz = ux * vy - uy * vx\n    const absSq = crossx * crossx + crossy * crossy + crossz * crossz\n    const area3D = Math.sqrt(absSq) / 2\n    return area3D\n  }\n  static centroid(a, b, c) {\n    const x = (a.x + b.x + c.x) / 3\n    const y = (a.y + b.y + c.y) / 3\n    return new Coordinate(x, y)\n  }\n  interpolateZ(p) {\n    if (p === null) throw new IllegalArgumentException('Supplied point is null.')\n    return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)\n  }\n  longestSideLength() {\n    return Triangle.longestSideLength(this.p0, this.p1, this.p2)\n  }\n  isAcute() {\n    return Triangle.isAcute(this.p0, this.p1, this.p2)\n  }\n  circumcentre() {\n    return Triangle.circumcentre(this.p0, this.p1, this.p2)\n  }\n  inCentre() {\n    return Triangle.inCentre(this.p0, this.p1, this.p2)\n  }\n  area() {\n    return Triangle.area(this.p0, this.p1, this.p2)\n  }\n  signedArea() {\n    return Triangle.signedArea(this.p0, this.p1, this.p2)\n  }\n  area3D() {\n    return Triangle.area3D(this.p0, this.p1, this.p2)\n  }\n  centroid() {\n    return Triangle.centroid(this.p0, this.p1, this.p2)\n  }\n}\n","import Location from '../../geom/Location.js'\nimport LineString from '../../geom/LineString.js'\nimport Position from '../../geomgraph/Position.js'\nimport Point from '../../geom/Point.js'\nimport LinearRing from '../../geom/LinearRing.js'\nimport Orientation from '../../algorithm/Orientation.js'\nimport MultiPolygon from '../../geom/MultiPolygon.js'\nimport Label from '../../geomgraph/Label.js'\nimport CoordinateArrays from '../../geom/CoordinateArrays.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Distance from '../../algorithm/Distance.js'\nimport MultiLineString from '../../geom/MultiLineString.js'\nimport Triangle from '../../geom/Triangle.js'\nimport NodedSegmentString from '../../noding/NodedSegmentString.js'\nimport Polygon from '../../geom/Polygon.js'\nimport MultiPoint from '../../geom/MultiPoint.js'\nimport GeometryCollection from '../../geom/GeometryCollection.js'\nimport UnsupportedOperationException from '../../../../../java/lang/UnsupportedOperationException.js'\nexport default class OffsetCurveSetBuilder {\n  constructor() {\n    OffsetCurveSetBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._inputGeom = null\n    this._distance = null\n    this._curveBuilder = null\n    this._curveList = new ArrayList()\n    const inputGeom = arguments[0], distance = arguments[1], curveBuilder = arguments[2]\n    this._inputGeom = inputGeom\n    this._distance = distance\n    this._curveBuilder = curveBuilder\n  }\n  addRingSide(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n    if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null\n    let leftLoc = cwLeftLoc\n    let rightLoc = cwRightLoc\n    if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {\n      leftLoc = cwRightLoc\n      rightLoc = cwLeftLoc\n      side = Position.opposite(side)\n    }\n    const curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance)\n    this.addCurve(curve, leftLoc, rightLoc)\n  }\n  addRingBothSides(coord, distance) {\n    this.addRingSide(coord, distance, Position.LEFT, Location.EXTERIOR, Location.INTERIOR)\n    this.addRingSide(coord, distance, Position.RIGHT, Location.INTERIOR, Location.EXTERIOR)\n  }\n  addPoint(p) {\n    if (this._distance <= 0.0) return null\n    const coord = p.getCoordinates()\n    const curve = this._curveBuilder.getLineCurve(coord, this._distance)\n    this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR)\n  }\n  addPolygon(p) {\n    let offsetDistance = this._distance\n    let offsetSide = Position.LEFT\n    if (this._distance < 0.0) {\n      offsetDistance = -this._distance\n      offsetSide = Position.RIGHT\n    }\n    const shell = p.getExteriorRing()\n    const shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates())\n    if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null\n    if (this._distance <= 0.0 && shellCoord.length < 3) return null\n    this.addRingSide(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR)\n    for (let i = 0; i < p.getNumInteriorRing(); i++) {\n      const hole = p.getInteriorRingN(i)\n      const holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates())\n      if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue\n      this.addRingSide(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR)\n    }\n  }\n  isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n    const tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2])\n    const inCentre = tri.inCentre()\n    const distToCentre = Distance.pointToSegment(inCentre, tri.p0, tri.p1)\n    return distToCentre < Math.abs(bufferDistance)\n  }\n  addLineString(line) {\n    if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null\n    const coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates())\n    if (CoordinateArrays.isRing(coord) && !this._curveBuilder.getBufferParameters().isSingleSided()) {\n      this.addRingBothSides(coord, this._distance)\n    } else {\n      const curve = this._curveBuilder.getLineCurve(coord, this._distance)\n      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR)\n    }\n  }\n  add(g) {\n    if (g.isEmpty()) return null\n    if (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getGeometryType())\n  }\n  addCurve(coord, leftLoc, rightLoc) {\n    if (coord === null || coord.length < 2) return null\n    const e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc))\n    this._curveList.add(e)\n  }\n  getCurves() {\n    this.add(this._inputGeom)\n    return this._curveList\n  }\n  isErodedCompletely(ring, bufferDistance) {\n    const ringCoord = ring.getCoordinates()\n    if (ringCoord.length < 4) return bufferDistance < 0\n    if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance)\n    const env = ring.getEnvelopeInternal()\n    const envMinDimension = Math.min(env.getHeight(), env.getWidth())\n    if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true\n    return false\n  }\n  addCollection(gc) {\n    for (let i = 0; i < gc.getNumGeometries(); i++) {\n      const g = gc.getGeometryN(i)\n      this.add(g)\n    }\n  }\n}\n","export default class PointOnGeometryLocator {\n  locate(p) {}\n}\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nexport default class Iterator {\n  /**\n     * Returns true if the iteration has more elements.\n     * @return {boolean}\n     */\n  hasNext() {}\n\n  /**\n     * Returns the next element in the iteration.\n     * @return {Object}\n     */\n  next() {}\n\n  /**\n     * Removes from the underlying collection the last element returned by the\n     * iterator (optional operation).\n     */\n  remove() {}\n}\n","import Iterator from '../../../../java/util/Iterator.js'\nimport NoSuchElementException from '../../../../java/util/NoSuchElementException.js'\nimport GeometryCollection from './GeometryCollection.js'\nimport UnsupportedOperationException from '../../../../java/lang/UnsupportedOperationException.js'\nexport default class GeometryCollectionIterator {\n  constructor() {\n    GeometryCollectionIterator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._parent = null\n    this._atStart = null\n    this._max = null\n    this._index = null\n    this._subcollectionIterator = null\n    const parent = arguments[0]\n    this._parent = parent\n    this._atStart = true\n    this._index = 0\n    this._max = parent.getNumGeometries()\n  }\n  static isAtomic(geom) {\n    return !(geom instanceof GeometryCollection)\n  }\n  next() {\n    if (this._atStart) {\n      this._atStart = false\n      if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++\n      return this._parent\n    }\n    if (this._subcollectionIterator !== null) \n      if (this._subcollectionIterator.hasNext()) \n        return this._subcollectionIterator.next()\n      else \n        this._subcollectionIterator = null\n      \n    \n    if (this._index >= this._max) \n      throw new NoSuchElementException()\n    \n    const obj = this._parent.getGeometryN(this._index++)\n    if (obj instanceof GeometryCollection) {\n      this._subcollectionIterator = new GeometryCollectionIterator(obj)\n      return this._subcollectionIterator.next()\n    }\n    return obj\n  }\n  hasNext() {\n    if (this._atStart) \n      return true\n    \n    if (this._subcollectionIterator !== null) {\n      if (this._subcollectionIterator.hasNext()) \n        return true\n      \n      this._subcollectionIterator = null\n    }\n    if (this._index >= this._max) \n      return false\n    \n    return true\n  }\n  remove() {\n    throw new UnsupportedOperationException(this.getClass().getName())\n  }\n  get interfaces_() {\n    return [Iterator]\n  }\n}\n","import Location from '../../geom/Location.js'\nimport Polygon from '../../geom/Polygon.js'\nimport PointLocation from '../PointLocation.js'\nimport PointOnGeometryLocator from './PointOnGeometryLocator.js'\nimport GeometryCollectionIterator from '../../geom/GeometryCollectionIterator.js'\nimport GeometryCollection from '../../geom/GeometryCollection.js'\nexport default class SimplePointInAreaLocator {\n  constructor() {\n    SimplePointInAreaLocator.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._geom = null\n    const geom = arguments[0]\n    this._geom = geom\n  }\n  static locatePointInPolygon(p, poly) {\n    if (poly.isEmpty()) return Location.EXTERIOR\n    const shell = poly.getExteriorRing()\n    const shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell)\n    if (shellLoc !== Location.INTERIOR) return shellLoc\n    for (let i = 0; i < poly.getNumInteriorRing(); i++) {\n      const hole = poly.getInteriorRingN(i)\n      const holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole)\n      if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY\n      if (holeLoc === Location.INTERIOR) return Location.EXTERIOR\n    }\n    return Location.INTERIOR\n  }\n  static locatePointInRing(p, ring) {\n    if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR\n    return PointLocation.locateInRing(p, ring.getCoordinates())\n  }\n  static isContained(p, geom) {\n    return Location.EXTERIOR !== SimplePointInAreaLocator.locate(p, geom)\n  }\n  static locate(p, geom) {\n    if (geom.isEmpty()) return Location.EXTERIOR\n    if (!geom.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR\n    return SimplePointInAreaLocator.locateInGeometry(p, geom)\n  }\n  static containsPointInPolygon(p, poly) {\n    return Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly)\n  }\n  static locateInGeometry(p, geom) {\n    if (geom instanceof Polygon) \n      return SimplePointInAreaLocator.locatePointInPolygon(p, geom)\n    \n    if (geom instanceof GeometryCollection) {\n      const geomi = new GeometryCollectionIterator(geom)\n      while (geomi.hasNext()) {\n        const g2 = geomi.next()\n        if (g2 !== geom) {\n          const loc = SimplePointInAreaLocator.locateInGeometry(p, g2)\n          if (loc !== Location.EXTERIOR) return loc\n        }\n      }\n    }\n    return Location.EXTERIOR\n  }\n  locate(p) {\n    return SimplePointInAreaLocator.locate(p, this._geom)\n  }\n  get interfaces_() {\n    return [PointOnGeometryLocator]\n  }\n}\n","import StringBuffer from '../../../../java/lang/StringBuffer.js'\nimport Location from '../geom/Location.js'\nimport Position from './Position.js'\nimport TopologyException from '../geom/TopologyException.js'\nimport System from '../../../../java/lang/System.js'\nimport SimplePointInAreaLocator from '../algorithm/locate/SimplePointInAreaLocator.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport Assert from '../util/Assert.js'\nimport TreeMap from '../../../../java/util/TreeMap.js'\nexport default class EdgeEndStar {\n  constructor() {\n    EdgeEndStar.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edgeMap = new TreeMap()\n    this._edgeList = null\n    this._ptInAreaLocation = [Location.NONE, Location.NONE]\n  }\n  getNextCW(ee) {\n    this.getEdges()\n    const i = this._edgeList.indexOf(ee)\n    let iNextCW = i - 1\n    if (i === 0) iNextCW = this._edgeList.size() - 1\n    return this._edgeList.get(iNextCW)\n  }\n  propagateSideLabels(geomIndex) {\n    let startLoc = Location.NONE\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT)\n    }\n    if (startLoc === Location.NONE) return null\n    let currLoc = startLoc\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      if (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc)\n      if (label.isArea(geomIndex)) {\n        const leftLoc = label.getLocation(geomIndex, Position.LEFT)\n        const rightLoc = label.getLocation(geomIndex, Position.RIGHT)\n        if (rightLoc !== Location.NONE) {\n          if (rightLoc !== currLoc) throw new TopologyException('side location conflict', e.getCoordinate())\n          if (leftLoc === Location.NONE) \n            Assert.shouldNeverReachHere('found single null side (at ' + e.getCoordinate() + ')')\n          \n          currLoc = leftLoc\n        } else {\n          Assert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side')\n          label.setLocation(geomIndex, Position.RIGHT, currLoc)\n          label.setLocation(geomIndex, Position.LEFT, currLoc)\n        }\n      }\n    }\n  }\n  getCoordinate() {\n    const it = this.iterator()\n    if (!it.hasNext()) return null\n    const e = it.next()\n    return e.getCoordinate()\n  }\n  checkAreaLabelsConsistent(geomIndex) {\n    const edges = this.getEdges()\n    if (edges.size() <= 0) return true\n    const lastEdgeIndex = edges.size() - 1\n    const startLabel = edges.get(lastEdgeIndex).getLabel()\n    const startLoc = startLabel.getLocation(geomIndex, Position.LEFT)\n    Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge')\n    let currLoc = startLoc\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge')\n      const leftLoc = label.getLocation(geomIndex, Position.LEFT)\n      const rightLoc = label.getLocation(geomIndex, Position.RIGHT)\n      if (leftLoc === rightLoc) \n        return false\n      \n      if (rightLoc !== currLoc) \n        return false\n      \n      currLoc = leftLoc\n    }\n    return true\n  }\n  findIndex(eSearch) {\n    this.iterator()\n    for (let i = 0; i < this._edgeList.size(); i++) {\n      const e = this._edgeList.get(i)\n      if (e === eSearch) return i\n    }\n    return -1\n  }\n  iterator() {\n    return this.getEdges().iterator()\n  }\n  getEdges() {\n    if (this._edgeList === null) \n      this._edgeList = new ArrayList(this._edgeMap.values())\n    \n    return this._edgeList\n  }\n  getLocation(geomIndex, p, geom) {\n    if (this._ptInAreaLocation[geomIndex] === Location.NONE) \n      this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry())\n    \n    return this._ptInAreaLocation[geomIndex]\n  }\n  toString() {\n    const buf = new StringBuffer()\n    buf.append('EdgeEndStar:   ' + this.getCoordinate())\n    buf.append('\\n')\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      buf.append(e)\n      buf.append('\\n')\n    }\n    return buf.toString()\n  }\n  computeEdgeEndLabels(boundaryNodeRule) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ee = it.next()\n      ee.computeLabel(boundaryNodeRule)\n    }\n  }\n  computeLabelling(geomGraph) {\n    this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule())\n    this.propagateSideLabels(0)\n    this.propagateSideLabels(1)\n    const hasDimensionalCollapseEdge = [false, false]\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      for (let geomi = 0; geomi < 2; geomi++) \n        if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true\n      \n    }\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      const label = e.getLabel()\n      for (let geomi = 0; geomi < 2; geomi++) \n        if (label.isAnyNull(geomi)) {\n          let loc = Location.NONE\n          if (hasDimensionalCollapseEdge[geomi]) {\n            loc = Location.EXTERIOR\n          } else {\n            const p = e.getCoordinate()\n            loc = this.getLocation(geomi, p, geomGraph)\n          }\n          label.setAllLocationsIfNull(geomi, loc)\n        }\n      \n    }\n  }\n  getDegree() {\n    return this._edgeMap.size()\n  }\n  insertEdgeEnd(e, obj) {\n    this._edgeMap.put(e, obj)\n    this._edgeList = null\n  }\n  print(out) {\n    System.out.println('EdgeEndStar:   ' + this.getCoordinate())\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const e = it.next()\n      e.print(out)\n    }\n  }\n  isAreaLabelsConsistent(geomGraph) {\n    this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule())\n    return this.checkAreaLabelsConsistent(0)\n  }\n}\n","import Location from '../geom/Location.js'\nimport Position from './Position.js'\nimport TopologyException from '../geom/TopologyException.js'\nimport Label from './Label.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport EdgeEndStar from './EdgeEndStar.js'\nimport System from '../../../../java/lang/System.js'\nimport Quadrant from './Quadrant.js'\nimport Assert from '../util/Assert.js'\nexport default class DirectedEdgeStar extends EdgeEndStar {\n  constructor() {\n    super()\n    DirectedEdgeStar.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._resultAreaEdgeList = null\n    this._label = null\n    this._SCANNING_FOR_INCOMING = 1\n    this._LINKING_TO_OUTGOING = 2\n  }\n  linkResultDirectedEdges() {\n    this.getResultAreaEdges()\n    let firstOut = null\n    let incoming = null\n    let state = this._SCANNING_FOR_INCOMING\n    for (let i = 0; i < this._resultAreaEdgeList.size(); i++) {\n      const nextOut = this._resultAreaEdgeList.get(i)\n      const nextIn = nextOut.getSym()\n      if (!nextOut.getLabel().isArea()) continue\n      if (firstOut === null && nextOut.isInResult()) firstOut = nextOut\n      switch (state) {\n      case this._SCANNING_FOR_INCOMING:\n        if (!nextIn.isInResult()) continue\n        incoming = nextIn\n        state = this._LINKING_TO_OUTGOING\n        break\n      case this._LINKING_TO_OUTGOING:\n        if (!nextOut.isInResult()) continue\n        incoming.setNext(nextOut)\n        state = this._SCANNING_FOR_INCOMING\n        break\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      if (firstOut === null) throw new TopologyException('no outgoing dirEdge found', this.getCoordinate())\n      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge')\n      incoming.setNext(firstOut)\n    }\n  }\n  insert(ee) {\n    const de = ee\n    this.insertEdgeEnd(de, de)\n  }\n  getRightmostEdge() {\n    const edges = this.getEdges()\n    const size = edges.size()\n    if (size < 1) return null\n    const de0 = edges.get(0)\n    if (size === 1) return de0\n    const deLast = edges.get(size - 1)\n    const quad0 = de0.getQuadrant()\n    const quad1 = deLast.getQuadrant()\n    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) {\n      return de0\n    } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) {\n      return deLast\n    } else {\n      const nonHorizontalEdge = null\n      if (de0.getDy() !== 0) return de0; else if (deLast.getDy() !== 0) return deLast\n    }\n    Assert.shouldNeverReachHere('found two horizontal edges incident on node')\n    return null\n  }\n  updateLabelling(nodeLabel) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      const label = de.getLabel()\n      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0))\n      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1))\n    }\n  }\n  linkAllDirectedEdges() {\n    this.getEdges()\n    let prevOut = null\n    let firstIn = null\n    for (let i = this._edgeList.size() - 1; i >= 0; i--) {\n      const nextOut = this._edgeList.get(i)\n      const nextIn = nextOut.getSym()\n      if (firstIn === null) firstIn = nextIn\n      if (prevOut !== null) nextIn.setNext(prevOut)\n      prevOut = nextOut\n    }\n    firstIn.setNext(prevOut)\n  }\n  computeDepths() {\n    if (arguments.length === 1) {\n      const de = arguments[0]\n      const edgeIndex = this.findIndex(de)\n      const startDepth = de.getDepth(Position.LEFT)\n      const targetLastDepth = de.getDepth(Position.RIGHT)\n      const nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth)\n      const lastDepth = this.computeDepths(0, edgeIndex, nextDepth)\n      if (lastDepth !== targetLastDepth) throw new TopologyException('depth mismatch at ' + de.getCoordinate())\n    } else if (arguments.length === 3) {\n      const startIndex = arguments[0], endIndex = arguments[1], startDepth = arguments[2]\n      let currDepth = startDepth\n      for (let i = startIndex; i < endIndex; i++) {\n        const nextDe = this._edgeList.get(i)\n        nextDe.setEdgeDepths(Position.RIGHT, currDepth)\n        currDepth = nextDe.getDepth(Position.LEFT)\n      }\n      return currDepth\n    }\n  }\n  mergeSymLabels() {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      const label = de.getLabel()\n      label.merge(de.getSym().getLabel())\n    }\n  }\n  linkMinimalDirectedEdges(er) {\n    let firstOut = null\n    let incoming = null\n    let state = this._SCANNING_FOR_INCOMING\n    for (let i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n      const nextOut = this._resultAreaEdgeList.get(i)\n      const nextIn = nextOut.getSym()\n      if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut\n      switch (state) {\n      case this._SCANNING_FOR_INCOMING:\n        if (nextIn.getEdgeRing() !== er) continue\n        incoming = nextIn\n        state = this._LINKING_TO_OUTGOING\n        break\n      case this._LINKING_TO_OUTGOING:\n        if (nextOut.getEdgeRing() !== er) continue\n        incoming.setNextMin(nextOut)\n        state = this._SCANNING_FOR_INCOMING\n        break\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge')\n      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge')\n      incoming.setNextMin(firstOut)\n    }\n  }\n  getOutgoingDegree() {\n    if (arguments.length === 0) {\n      let degree = 0\n      for (let it = this.iterator(); it.hasNext(); ) {\n        const de = it.next()\n        if (de.isInResult()) degree++\n      }\n      return degree\n    } else if (arguments.length === 1) {\n      const er = arguments[0]\n      let degree = 0\n      for (let it = this.iterator(); it.hasNext(); ) {\n        const de = it.next()\n        if (de.getEdgeRing() === er) degree++\n      }\n      return degree\n    }\n  }\n  getLabel() {\n    return this._label\n  }\n  findCoveredLineEdges() {\n    let startLoc = Location.NONE\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const nextOut = it.next()\n      const nextIn = nextOut.getSym()\n      if (!nextOut.isLineEdge()) {\n        if (nextOut.isInResult()) {\n          startLoc = Location.INTERIOR\n          break\n        }\n        if (nextIn.isInResult()) {\n          startLoc = Location.EXTERIOR\n          break\n        }\n      }\n    }\n    if (startLoc === Location.NONE) return null\n    let currLoc = startLoc\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const nextOut = it.next()\n      const nextIn = nextOut.getSym()\n      if (nextOut.isLineEdge()) {\n        nextOut.getEdge().setCovered(currLoc === Location.INTERIOR)\n      } else {\n        if (nextOut.isInResult()) currLoc = Location.EXTERIOR\n        if (nextIn.isInResult()) currLoc = Location.INTERIOR\n      }\n    }\n  }\n  computeLabelling(geom) {\n    super.computeLabelling.call(this, geom)\n    this._label = new Label(Location.NONE)\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ee = it.next()\n      const e = ee.getEdge()\n      const eLabel = e.getLabel()\n      for (let i = 0; i < 2; i++) {\n        const eLoc = eLabel.getLocation(i)\n        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR)\n      }\n    }\n  }\n  print(out) {\n    System.out.println('DirectedEdgeStar: ' + this.getCoordinate())\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      out.print('out ')\n      de.print(out)\n      out.println()\n      out.print('in ')\n      de.getSym().print(out)\n      out.println()\n    }\n  }\n  getResultAreaEdges() {\n    if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList\n    this._resultAreaEdgeList = new ArrayList()\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const de = it.next()\n      if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de)\n    }\n    return this._resultAreaEdgeList\n  }\n}\n","import DirectedEdgeStar from '../../geomgraph/DirectedEdgeStar.js'\nimport Node from '../../geomgraph/Node.js'\nimport NodeFactory from '../../geomgraph/NodeFactory.js'\nexport default class OverlayNodeFactory extends NodeFactory {\n  constructor() {\n    super()\n  }\n  createNode(coord) {\n    return new Node(coord, new DirectedEdgeStar())\n  }\n}\n","import Comparable from '../../../../java/lang/Comparable.js'\nimport CoordinateArrays from '../geom/CoordinateArrays.js'\nexport default class OrientedCoordinateArray {\n  constructor() {\n    OrientedCoordinateArray.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._pts = null\n    this._orientation = null\n    const pts = arguments[0]\n    this._pts = pts\n    this._orientation = OrientedCoordinateArray.orientation(pts)\n  }\n  static orientation(pts) {\n    return CoordinateArrays.increasingDirection(pts) === 1\n  }\n  static compareOriented(pts1, orientation1, pts2, orientation2) {\n    const dir1 = orientation1 ? 1 : -1\n    const dir2 = orientation2 ? 1 : -1\n    const limit1 = orientation1 ? pts1.length : -1\n    const limit2 = orientation2 ? pts2.length : -1\n    let i1 = orientation1 ? 0 : pts1.length - 1\n    let i2 = orientation2 ? 0 : pts2.length - 1\n    while (true) {\n      const compPt = pts1[i1].compareTo(pts2[i2])\n      if (compPt !== 0) return compPt\n      i1 += dir1\n      i2 += dir2\n      const done1 = i1 === limit1\n      const done2 = i2 === limit2\n      if (done1 && !done2) return -1\n      if (!done1 && done2) return 1\n      if (done1 && done2) return 0\n    }\n  }\n  compareTo(o1) {\n    const oca = o1\n    const comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation)\n    return comp\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import OrientedCoordinateArray from '../noding/OrientedCoordinateArray.js'\nimport ArrayList from '../../../../java/util/ArrayList.js'\nimport TreeMap from '../../../../java/util/TreeMap.js'\nexport default class EdgeList {\n  constructor() {\n    EdgeList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._edges = new ArrayList()\n    this._ocaMap = new TreeMap()\n  }\n  print(out) {\n    out.print('MULTILINESTRING ( ')\n    for (let j = 0; j < this._edges.size(); j++) {\n      const e = this._edges.get(j)\n      if (j > 0) out.print(',')\n      out.print('(')\n      const pts = e.getCoordinates()\n      for (let i = 0; i < pts.length; i++) {\n        if (i > 0) out.print(',')\n        out.print(pts[i].x + ' ' + pts[i].y)\n      }\n      out.println(')')\n    }\n    out.print(')  ')\n  }\n  addAll(edgeColl) {\n    for (let i = edgeColl.iterator(); i.hasNext(); ) \n      this.add(i.next())\n    \n  }\n  findEdgeIndex(e) {\n    for (let i = 0; i < this._edges.size(); i++) \n      if (this._edges.get(i).equals(e)) return i\n    \n    return -1\n  }\n  iterator() {\n    return this._edges.iterator()\n  }\n  getEdges() {\n    return this._edges\n  }\n  get(i) {\n    return this._edges.get(i)\n  }\n  findEqualEdge(e) {\n    const oca = new OrientedCoordinateArray(e.getCoordinates())\n    const matchEdge = this._ocaMap.get(oca)\n    return matchEdge\n  }\n  add(e) {\n    this._edges.add(e)\n    const oca = new OrientedCoordinateArray(e.getCoordinates())\n    this._ocaMap.put(oca, e)\n  }\n}\n","import SegmentIntersector from './SegmentIntersector.js'\nexport default class IntersectionAdder {\n  constructor() {\n    IntersectionAdder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._hasIntersection = false\n    this._hasProper = false\n    this._hasProperInterior = false\n    this._hasInterior = false\n    this._properIntersectionPoint = null\n    this._li = null\n    this._isSelfIntersection = null\n    this.numIntersections = 0\n    this.numInteriorIntersections = 0\n    this.numProperIntersections = 0\n    this.numTests = 0\n    const li = arguments[0]\n    this._li = li\n  }\n  static isAdjacentSegments(i1, i2) {\n    return Math.abs(i1 - i2) === 1\n  }\n  isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1) \n      if (this._li.getIntersectionNum() === 1) {\n        if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true\n        if (e0.isClosed()) {\n          const maxSegIndex = e0.size() - 1\n          if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) \n            return true\n          \n        }\n      }\n    \n    return false\n  }\n  getProperIntersectionPoint() {\n    return this._properIntersectionPoint\n  }\n  hasProperInteriorIntersection() {\n    return this._hasProperInterior\n  }\n  getLineIntersector() {\n    return this._li\n  }\n  hasProperIntersection() {\n    return this._hasProper\n  }\n  processIntersections(e0, segIndex0, e1, segIndex1) {\n    if (e0 === e1 && segIndex0 === segIndex1) return null\n    this.numTests++\n    const p00 = e0.getCoordinates()[segIndex0]\n    const p01 = e0.getCoordinates()[segIndex0 + 1]\n    const p10 = e1.getCoordinates()[segIndex1]\n    const p11 = e1.getCoordinates()[segIndex1 + 1]\n    this._li.computeIntersection(p00, p01, p10, p11)\n    if (this._li.hasIntersection()) {\n      this.numIntersections++\n      if (this._li.isInteriorIntersection()) {\n        this.numInteriorIntersections++\n        this._hasInterior = true\n      }\n      if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n        this._hasIntersection = true\n        e0.addIntersections(this._li, segIndex0, 0)\n        e1.addIntersections(this._li, segIndex1, 1)\n        if (this._li.isProper()) {\n          this.numProperIntersections++\n          this._hasProper = true\n          this._hasProperInterior = true\n        }\n      }\n    }\n  }\n  hasIntersection() {\n    return this._hasIntersection\n  }\n  isDone() {\n    return false\n  }\n  hasInteriorIntersection() {\n    return this._hasInterior\n  }\n  get interfaces_() {\n    return [SegmentIntersector]\n  }\n}\n","import Coordinate from '../geom/Coordinate.js'\nimport Comparable from '../../../../java/lang/Comparable.js'\nexport default class EdgeIntersection {\n  constructor() {\n    EdgeIntersection.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.coord = null\n    this.segmentIndex = null\n    this.dist = null\n    const coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2]\n    this.coord = new Coordinate(coord)\n    this.segmentIndex = segmentIndex\n    this.dist = dist\n  }\n  getSegmentIndex() {\n    return this.segmentIndex\n  }\n  getCoordinate() {\n    return this.coord\n  }\n  print(out) {\n    out.print(this.coord)\n    out.print(' seg # = ' + this.segmentIndex)\n    out.println(' dist = ' + this.dist)\n  }\n  compareTo(obj) {\n    const other = obj\n    return this.compare(other.segmentIndex, other.dist)\n  }\n  isEndPoint(maxSegmentIndex) {\n    if (this.segmentIndex === 0 && this.dist === 0.0) return true\n    if (this.segmentIndex === maxSegmentIndex) return true\n    return false\n  }\n  toString() {\n    return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist\n  }\n  getDistance() {\n    return this.dist\n  }\n  compare(segmentIndex, dist) {\n    if (this.segmentIndex < segmentIndex) return -1\n    if (this.segmentIndex > segmentIndex) return 1\n    if (this.dist < dist) return -1\n    if (this.dist > dist) return 1\n    return 0\n  }\n  get interfaces_() {\n    return [Comparable]\n  }\n}\n","import EdgeIntersection from './EdgeIntersection.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Label from './Label.js'\nimport Edge from './Edge.js'\nimport TreeMap from '../../../../java/util/TreeMap.js'\nexport default class EdgeIntersectionList {\n  constructor() {\n    EdgeIntersectionList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._nodeMap = new TreeMap()\n    this.edge = null\n    const edge = arguments[0]\n    this.edge = edge\n  }\n  print(out) {\n    out.println('Intersections:')\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ei = it.next()\n      ei.print(out)\n    }\n  }\n  addEndpoints() {\n    const maxSegIndex = this.edge.pts.length - 1\n    this.add(this.edge.pts[0], 0, 0.0)\n    this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0)\n  }\n  createSplitEdge(ei0, ei1) {\n    let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n    const lastSegStartPt = this.edge.pts[ei1.segmentIndex]\n    const useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt)\n    if (!useIntPt1) \n      npts--\n    \n    const pts = new Array(npts).fill(null)\n    let ipt = 0\n    pts[ipt++] = new Coordinate(ei0.coord)\n    for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) \n      pts[ipt++] = this.edge.pts[i]\n    \n    if (useIntPt1) pts[ipt] = ei1.coord\n    return new Edge(pts, new Label(this.edge._label))\n  }\n  add(intPt, segmentIndex, dist) {\n    const eiNew = new EdgeIntersection(intPt, segmentIndex, dist)\n    const ei = this._nodeMap.get(eiNew)\n    if (ei !== null) \n      return ei\n    \n    this._nodeMap.put(eiNew, eiNew)\n    return eiNew\n  }\n  isIntersection(pt) {\n    for (let it = this.iterator(); it.hasNext(); ) {\n      const ei = it.next()\n      if (ei.coord.equals(pt)) return true\n    }\n    return false\n  }\n  iterator() {\n    return this._nodeMap.values().iterator()\n  }\n  addSplitEdges(edgeList) {\n    this.addEndpoints()\n    const it = this.iterator()\n    let eiPrev = it.next()\n    while (it.hasNext()) {\n      const ei = it.next()\n      const newEdge = this.createSplitEdge(eiPrev, ei)\n      edgeList.add(newEdge)\n      eiPrev = ei\n    }\n  }\n}\n","import Location from './Location.js'\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException.js'\nimport Dimension from './Dimension.js'\nimport Cloneable from '../../../../java/lang/Cloneable.js'\nimport StringBuilder from '../../../../java/lang/StringBuilder.js'\nexport default class IntersectionMatrix {\n  constructor() {\n    IntersectionMatrix.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._matrix = null\n    if (arguments.length === 0) {\n      this._matrix = Array(3).fill().map(() => Array(3))\n      this.setAll(Dimension.FALSE)\n    } else if (arguments.length === 1) {\n      if (typeof arguments[0] === 'string') {\n        const elements = arguments[0]\n        IntersectionMatrix.constructor_.call(this)\n        this.set(elements)\n      } else if (arguments[0] instanceof IntersectionMatrix) {\n        const other = arguments[0]\n        IntersectionMatrix.constructor_.call(this)\n        this._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR]\n        this._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY]\n        this._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR]\n        this._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR]\n        this._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY]\n        this._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR]\n        this._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR]\n        this._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY]\n        this._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR]\n      }\n    }\n  }\n  static isTrue(actualDimensionValue) {\n    if (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) \n      return true\n    \n    return false\n  }\n  static matches() {\n    if (Number.isInteger(arguments[0]) && typeof arguments[1] === 'string') {\n      const actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1]\n      if (requiredDimensionSymbol === Dimension.SYM_DONTCARE) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) \n        return true\n      \n      if (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) \n        return true\n      \n      return false\n    } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string') {\n      const actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1]\n      const m = new IntersectionMatrix(actualDimensionSymbols)\n      return m.matches(requiredDimensionSymbols)\n    }\n  }\n  isIntersects() {\n    return !this.isDisjoint()\n  }\n  set() {\n    if (arguments.length === 1) {\n      const dimensionSymbols = arguments[0]\n      for (let i = 0; i < dimensionSymbols.length; i++) {\n        const row = Math.trunc(i / 3)\n        const col = i % 3\n        this._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i))\n      }\n    } else if (arguments.length === 3) {\n      const row = arguments[0], column = arguments[1], dimensionValue = arguments[2]\n      this._matrix[row][column] = dimensionValue\n    }\n  }\n  isContains() {\n    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE\n  }\n  isWithin() {\n    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE\n  }\n  isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA > dimensionOfGeometryB) \n      return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA)\n    \n    if (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) \n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]))\n    \n    return false\n  }\n  isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) \n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])\n    \n    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) \n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])\n    \n    return false\n  }\n  isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA !== dimensionOfGeometryB) \n      return false\n    \n    return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE\n  }\n  matches(requiredDimensionSymbols) {\n    if (requiredDimensionSymbols.length !== 9) \n      throw new IllegalArgumentException('Should be length 9: ' + requiredDimensionSymbols)\n    \n    for (let ai = 0; ai < 3; ai++) \n      for (let bi = 0; bi < 3; bi++) \n        if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) \n          return false\n        \n      \n    \n    return true\n  }\n  add(im) {\n    for (let i = 0; i < 3; i++) \n      for (let j = 0; j < 3; j++) \n        this.setAtLeast(i, j, im.get(i, j))\n      \n    \n  }\n  isDisjoint() {\n    return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE\n  }\n  isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n    if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) \n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR])\n    \n    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) \n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR])\n    \n    if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) \n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === 0\n    \n    return false\n  }\n  isCovers() {\n    const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY])\n    return hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE\n  }\n  isCoveredBy() {\n    const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY])\n    return hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE\n  }\n  setAtLeast() {\n    if (arguments.length === 1) {\n      const minimumDimensionSymbols = arguments[0]\n      for (let i = 0; i < minimumDimensionSymbols.length; i++) {\n        const row = Math.trunc(i / 3)\n        const col = i % 3\n        this.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)))\n      }\n    } else if (arguments.length === 3) {\n      const row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2]\n      if (this._matrix[row][column] < minimumDimensionValue) \n        this._matrix[row][column] = minimumDimensionValue\n      \n    }\n  }\n  setAtLeastIfValid(row, column, minimumDimensionValue) {\n    if (row >= 0 && column >= 0) \n      this.setAtLeast(row, column, minimumDimensionValue)\n    \n  }\n  toString() {\n    const builder = new StringBuilder('123456789')\n    for (let ai = 0; ai < 3; ai++) \n      for (let bi = 0; bi < 3; bi++) \n        builder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]))\n      \n    \n    return builder.toString()\n  }\n  setAll(dimensionValue) {\n    for (let ai = 0; ai < 3; ai++) \n      for (let bi = 0; bi < 3; bi++) \n        this._matrix[ai][bi] = dimensionValue\n      \n    \n  }\n  get(row, column) {\n    return this._matrix[row][column]\n  }\n  transpose() {\n    let temp = this._matrix[1][0]\n    this._matrix[1][0] = this._matrix[0][1]\n    this._matrix[0][1] = temp\n    temp = this._matrix[2][0]\n    this._matrix[2][0] = this._matrix[0][2]\n    this._matrix[0][2] = temp\n    temp = this._matrix[2][1]\n    this._matrix[2][1] = this._matrix[1][2]\n    this._matrix[1][2] = temp\n    return this\n  }\n  get interfaces_() {\n    return [Cloneable]\n  }\n}\n","import Location from '../geom/Location.js'\nimport Position from './Position.js'\nexport default class Depth {\n  constructor() {\n    Depth.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._depth = Array(2).fill().map(() => Array(3))\n    for (let i = 0; i < 2; i++) \n      for (let j = 0; j < 3; j++) \n        this._depth[i][j] = Depth.NULL_VALUE\n      \n    \n  }\n  static depthAtLocation(location) {\n    if (location === Location.EXTERIOR) return 0\n    if (location === Location.INTERIOR) return 1\n    return Depth.NULL_VALUE\n  }\n  getDepth(geomIndex, posIndex) {\n    return this._depth[geomIndex][posIndex]\n  }\n  setDepth(geomIndex, posIndex, depthValue) {\n    this._depth[geomIndex][posIndex] = depthValue\n  }\n  isNull() {\n    if (arguments.length === 0) {\n      for (let i = 0; i < 2; i++) \n        for (let j = 0; j < 3; j++) \n          if (this._depth[i][j] !== Depth.NULL_VALUE) return false\n        \n      \n      return true\n    } else if (arguments.length === 1) {\n      const geomIndex = arguments[0]\n      return this._depth[geomIndex][1] === Depth.NULL_VALUE\n    } else if (arguments.length === 2) {\n      const geomIndex = arguments[0], posIndex = arguments[1]\n      return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE\n    }\n  }\n  normalize() {\n    for (let i = 0; i < 2; i++) \n      if (!this.isNull(i)) {\n        let minDepth = this._depth[i][1]\n        if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2]\n        if (minDepth < 0) minDepth = 0\n        for (let j = 1; j < 3; j++) {\n          let newValue = 0\n          if (this._depth[i][j] > minDepth) newValue = 1\n          this._depth[i][j] = newValue\n        }\n      }\n    \n  }\n  getDelta(geomIndex) {\n    return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]\n  }\n  getLocation(geomIndex, posIndex) {\n    if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR\n    return Location.INTERIOR\n  }\n  toString() {\n    return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]\n  }\n  add() {\n    if (arguments.length === 1) {\n      const lbl = arguments[0]\n      for (let i = 0; i < 2; i++) \n        for (let j = 1; j < 3; j++) {\n          const loc = lbl.getLocation(i, j)\n          if (loc === Location.EXTERIOR || loc === Location.INTERIOR) \n            if (this.isNull(i, j)) \n              this._depth[i][j] = Depth.depthAtLocation(loc)\n            else this._depth[i][j] += Depth.depthAtLocation(loc)\n          \n        }\n      \n    } else if (arguments.length === 3) {\n      const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2]\n      if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++\n    }\n  }\n}\nDepth.NULL_VALUE = -1\n","import Arrays from '../../../../java/util/Arrays.js'\nimport System from '../../../../java/lang/System.js'\nexport default class IntArrayList {\n  constructor() {\n    IntArrayList.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._data = null\n    this._size = 0\n    if (arguments.length === 0) {\n      IntArrayList.constructor_.call(this, 10)\n    } else if (arguments.length === 1) {\n      const initialCapacity = arguments[0]\n      this._data = new Array(initialCapacity).fill(null)\n    }\n  }\n  size() {\n    return this._size\n  }\n  addAll(values) {\n    if (values === null) return null\n    if (values.length === 0) return null\n    this.ensureCapacity(this._size + values.length)\n    System.arraycopy(values, 0, this._data, this._size, values.length)\n    this._size += values.length\n  }\n  ensureCapacity(capacity) {\n    if (capacity <= this._data.length) return null\n    const newLength = Math.max(capacity, this._data.length * 2)\n    this._data = Arrays.copyOf(this._data, newLength)\n  }\n  toArray() {\n    const array = new Array(this._size).fill(null)\n    System.arraycopy(this._data, 0, array, 0, this._size)\n    return array\n  }\n  add(value) {\n    this.ensureCapacity(this._size + 1)\n    this._data[this._size] = value\n    ++ this._size\n  }\n}\n","import IntArrayList from '../../util/IntArrayList.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport Quadrant from '../Quadrant.js'\nexport default class MonotoneChainIndexer {\n  static toIntArray(list) {\n    const array = new Array(list.size()).fill(null)\n    for (let i = 0; i < array.length; i++) \n      array[i] = list.get(i).intValue()\n    \n    return array\n  }\n  findChainEnd(pts, start) {\n    const chainQuad = Quadrant.quadrant(pts[start], pts[start + 1])\n    let last = start + 1\n    while (last < pts.length) {\n      const quad = Quadrant.quadrant(pts[last - 1], pts[last])\n      if (quad !== chainQuad) break\n      last++\n    }\n    return last - 1\n  }\n  OLDgetChainStartIndices(pts) {\n    let start = 0\n    const startIndexList = new ArrayList()\n    startIndexList.add(start)\n    do {\n      const last = this.findChainEnd(pts, start)\n      startIndexList.add(last)\n      start = last\n    } while (start < pts.length - 1)\n    const startIndex = MonotoneChainIndexer.toIntArray(startIndexList)\n    return startIndex\n  }\n  getChainStartIndices(pts) {\n    let start = 0\n    const startIndexList = new IntArrayList(Math.trunc(pts.length / 2))\n    startIndexList.add(start)\n    do {\n      const last = this.findChainEnd(pts, start)\n      startIndexList.add(last)\n      start = last\n    } while (start < pts.length - 1)\n    return startIndexList.toArray()\n  }\n}\n","import MonotoneChainIndexer from './MonotoneChainIndexer.js'\nimport Envelope from '../../geom/Envelope.js'\nexport default class MonotoneChainEdge {\n  constructor() {\n    MonotoneChainEdge.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.e = null\n    this.pts = null\n    this.startIndex = null\n    const e = arguments[0]\n    this.e = e\n    this.pts = e.getCoordinates()\n    const mcb = new MonotoneChainIndexer()\n    this.startIndex = mcb.getChainStartIndices(this.pts)\n  }\n  getCoordinates() {\n    return this.pts\n  }\n  getMaxX(chainIndex) {\n    const x1 = this.pts[this.startIndex[chainIndex]].x\n    const x2 = this.pts[this.startIndex[chainIndex + 1]].x\n    return x1 > x2 ? x1 : x2\n  }\n  getMinX(chainIndex) {\n    const x1 = this.pts[this.startIndex[chainIndex]].x\n    const x2 = this.pts[this.startIndex[chainIndex + 1]].x\n    return x1 < x2 ? x1 : x2\n  }\n  computeIntersectsForChain() {\n    if (arguments.length === 4) {\n      const chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3]\n      this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si)\n    } else if (arguments.length === 6) {\n      const start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5]\n      if (end0 - start0 === 1 && end1 - start1 === 1) {\n        ei.addIntersections(this.e, start0, mce.e, start1)\n        return null\n      }\n      if (!this.overlaps(start0, end0, mce, start1, end1)) return null\n      const mid0 = Math.trunc((start0 + end0) / 2)\n      const mid1 = Math.trunc((start1 + end1) / 2)\n      if (start0 < mid0) {\n        if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei)\n        if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei)\n      }\n      if (mid0 < end0) {\n        if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei)\n        if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei)\n      }\n    }\n  }\n  overlaps(start0, end0, mce, start1, end1) {\n    return Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1])\n  }\n  getStartIndexes() {\n    return this.startIndex\n  }\n  computeIntersects(mce, si) {\n    for (let i = 0; i < this.startIndex.length - 1; i++) \n      for (let j = 0; j < mce.startIndex.length - 1; j++) \n        this.computeIntersectsForChain(i, mce, j, si)\n      \n    \n  }\n}\n","import EdgeIntersectionList from './EdgeIntersectionList.js'\nimport IntersectionMatrix from '../geom/IntersectionMatrix.js'\nimport Coordinate from '../geom/Coordinate.js'\nimport Label from './Label.js'\nimport Envelope from '../geom/Envelope.js'\nimport StringBuilder from '../../../../java/lang/StringBuilder.js'\nimport Depth from './Depth.js'\nimport GraphComponent from './GraphComponent.js'\nimport MonotoneChainEdge from './index/MonotoneChainEdge.js'\nimport Position from './Position.js'\nexport default class Edge extends GraphComponent {\n  constructor() {\n    super()\n    Edge.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this.pts = null\n    this._env = null\n    this.eiList = new EdgeIntersectionList(this)\n    this._name = null\n    this._mce = null\n    this._isIsolated = true\n    this._depth = new Depth()\n    this._depthDelta = 0\n    if (arguments.length === 1) {\n      const pts = arguments[0]\n      Edge.constructor_.call(this, pts, null)\n    } else if (arguments.length === 2) {\n      const pts = arguments[0], label = arguments[1]\n      this.pts = pts\n      this._label = label\n    }\n  }\n  static updateIM() {\n    if (arguments.length === 2 && (arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label)) {\n      const label = arguments[0], im = arguments[1]\n      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1)\n      if (label.isArea()) {\n        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2)\n        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2)\n      }\n    } else {\n      return super.updateIM.apply(this, arguments)\n    }\n  }\n  getDepth() {\n    return this._depth\n  }\n  getCollapsedEdge() {\n    const newPts = new Array(2).fill(null)\n    newPts[0] = this.pts[0]\n    newPts[1] = this.pts[1]\n    const newe = new Edge(newPts, Label.toLineLabel(this._label))\n    return newe\n  }\n  setIsolated(isIsolated) {\n    this._isIsolated = isIsolated\n  }\n  setName(name) {\n    this._name = name\n  }\n  equals(o) {\n    if (!(o instanceof Edge)) return false\n    const e = o\n    if (this.pts.length !== e.pts.length) return false\n    let isEqualForward = true\n    let isEqualReverse = true\n    let iRev = this.pts.length\n    for (let i = 0; i < this.pts.length; i++) {\n      if (!this.pts[i].equals2D(e.pts[i])) \n        isEqualForward = false\n      \n      if (!this.pts[i].equals2D(e.pts[-- iRev])) \n        isEqualReverse = false\n      \n      if (!isEqualForward && !isEqualReverse) return false\n    }\n    return true\n  }\n  getCoordinate() {\n    if (arguments.length === 0) {\n      if (this.pts.length > 0) return this.pts[0]\n      return null\n    } else if (arguments.length === 1) {\n      const i = arguments[0]\n      return this.pts[i]\n    }\n  }\n  isClosed() {\n    return this.pts[0].equals(this.pts[this.pts.length - 1])\n  }\n  getMaximumSegmentIndex() {\n    return this.pts.length - 1\n  }\n  setDepthDelta(depthDelta) {\n    this._depthDelta = depthDelta\n  }\n  getEdgeIntersectionList() {\n    return this.eiList\n  }\n  addIntersections(li, segmentIndex, geomIndex) {\n    for (let i = 0; i < li.getIntersectionNum(); i++) \n      this.addIntersection(li, segmentIndex, geomIndex, i)\n    \n  }\n  isIsolated() {\n    return this._isIsolated\n  }\n  getCoordinates() {\n    return this.pts\n  }\n  print(out) {\n    out.print('edge ' + this._name + ': ')\n    out.print('LINESTRING (')\n    for (let i = 0; i < this.pts.length; i++) {\n      if (i > 0) out.print(',')\n      out.print(this.pts[i].x + ' ' + this.pts[i].y)\n    }\n    out.print(')  ' + this._label + ' ' + this._depthDelta)\n  }\n  computeIM(im) {\n    Edge.updateIM(this._label, im)\n  }\n  isCollapsed() {\n    if (!this._label.isArea()) return false\n    if (this.pts.length !== 3) return false\n    if (this.pts[0].equals(this.pts[2])) return true\n    return false\n  }\n  getDepthDelta() {\n    return this._depthDelta\n  }\n  getNumPoints() {\n    return this.pts.length\n  }\n  printReverse(out) {\n    out.print('edge ' + this._name + ': ')\n    for (let i = this.pts.length - 1; i >= 0; i--) \n      out.print(this.pts[i] + ' ')\n    \n    out.println('')\n  }\n  getMonotoneChainEdge() {\n    if (this._mce === null) this._mce = new MonotoneChainEdge(this)\n    return this._mce\n  }\n  getEnvelope() {\n    if (this._env === null) {\n      this._env = new Envelope()\n      for (let i = 0; i < this.pts.length; i++) \n        this._env.expandToInclude(this.pts[i])\n      \n    }\n    return this._env\n  }\n  addIntersection(li, segmentIndex, geomIndex, intIndex) {\n    const intPt = new Coordinate(li.getIntersection(intIndex))\n    let normalizedSegmentIndex = segmentIndex\n    let dist = li.getEdgeDistance(geomIndex, intIndex)\n    const nextSegIndex = normalizedSegmentIndex + 1\n    if (nextSegIndex < this.pts.length) {\n      const nextPt = this.pts[nextSegIndex]\n      if (intPt.equals2D(nextPt)) {\n        normalizedSegmentIndex = nextSegIndex\n        dist = 0.0\n      }\n    }\n    const ei = this.eiList.add(intPt, normalizedSegmentIndex, dist)\n  }\n  toString() {\n    const builder = new StringBuilder()\n    builder.append('edge ' + this._name + ': ')\n    builder.append('LINESTRING (')\n    for (let i = 0; i < this.pts.length; i++) {\n      if (i > 0) builder.append(',')\n      builder.append(this.pts[i].x + ' ' + this.pts[i].y)\n    }\n    builder.append(')  ' + this._label + ' ' + this._depthDelta)\n    return builder.toString()\n  }\n  isPointwiseEqual(e) {\n    if (this.pts.length !== e.pts.length) return false\n    for (let i = 0; i < this.pts.length; i++) \n      if (!this.pts[i].equals2D(e.pts[i])) \n        return false\n      \n    \n    return true\n  }\n}\n","import Location from '../../geom/Location.js'\nimport BufferSubgraph from './BufferSubgraph.js'\nimport Position from '../../geomgraph/Position.js'\nimport MCIndexNoder from '../../noding/MCIndexNoder.js'\nimport OffsetCurveBuilder from './OffsetCurveBuilder.js'\nimport Collections from '../../../../../java/util/Collections.js'\nimport Label from '../../geomgraph/Label.js'\nimport PlanarGraph from '../../geomgraph/PlanarGraph.js'\nimport PolygonBuilder from '../overlay/PolygonBuilder.js'\nimport GeometryFactory from '../../geom/GeometryFactory.js'\nimport SubgraphDepthLocater from './SubgraphDepthLocater.js'\nimport OffsetCurveSetBuilder from './OffsetCurveSetBuilder.js'\nimport OverlayNodeFactory from '../overlay/OverlayNodeFactory.js'\nimport EdgeList from '../../geomgraph/EdgeList.js'\nimport ArrayList from '../../../../../java/util/ArrayList.js'\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector.js'\nimport IntersectionAdder from '../../noding/IntersectionAdder.js'\nimport Edge from '../../geomgraph/Edge.js'\nexport default class BufferBuilder {\n  constructor() {\n    BufferBuilder.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._bufParams = null\n    this._workingPrecisionModel = null\n    this._workingNoder = null\n    this._geomFact = null\n    this._graph = null\n    this._edgeList = new EdgeList()\n    const bufParams = arguments[0]\n    this._bufParams = bufParams\n  }\n  static convertSegStrings(it) {\n    const fact = new GeometryFactory()\n    const lines = new ArrayList()\n    while (it.hasNext()) {\n      const ss = it.next()\n      const line = fact.createLineString(ss.getCoordinates())\n      lines.add(line)\n    }\n    return fact.buildGeometry(lines)\n  }\n  static depthDelta(label) {\n    const lLoc = label.getLocation(0, Position.LEFT)\n    const rLoc = label.getLocation(0, Position.RIGHT)\n    if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1; else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1\n    return 0\n  }\n  createEmptyResultGeometry() {\n    const emptyGeom = this._geomFact.createPolygon()\n    return emptyGeom\n  }\n  getNoder(precisionModel) {\n    if (this._workingNoder !== null) return this._workingNoder\n    const noder = new MCIndexNoder()\n    const li = new RobustLineIntersector()\n    li.setPrecisionModel(precisionModel)\n    noder.setSegmentIntersector(new IntersectionAdder(li))\n    return noder\n  }\n  buffer(g, distance) {\n    let precisionModel = this._workingPrecisionModel\n    if (precisionModel === null) precisionModel = g.getPrecisionModel()\n    this._geomFact = g.getFactory()\n    const curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams)\n    const curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder)\n    const bufferSegStrList = curveSetBuilder.getCurves()\n    if (bufferSegStrList.size() <= 0) \n      return this.createEmptyResultGeometry()\n    \n    this.computeNodedEdges(bufferSegStrList, precisionModel)\n    this._graph = new PlanarGraph(new OverlayNodeFactory())\n    this._graph.addEdges(this._edgeList.getEdges())\n    const subgraphList = this.createSubgraphs(this._graph)\n    const polyBuilder = new PolygonBuilder(this._geomFact)\n    this.buildSubgraphs(subgraphList, polyBuilder)\n    const resultPolyList = polyBuilder.getPolygons()\n    if (resultPolyList.size() <= 0) \n      return this.createEmptyResultGeometry()\n    \n    const resultGeom = this._geomFact.buildGeometry(resultPolyList)\n    return resultGeom\n  }\n  computeNodedEdges(bufferSegStrList, precisionModel) {\n    const noder = this.getNoder(precisionModel)\n    noder.computeNodes(bufferSegStrList)\n    const nodedSegStrings = noder.getNodedSubstrings()\n    for (let i = nodedSegStrings.iterator(); i.hasNext(); ) {\n      const segStr = i.next()\n      const pts = segStr.getCoordinates()\n      if (pts.length === 2 && pts[0].equals2D(pts[1])) continue\n      const oldLabel = segStr.getData()\n      const edge = new Edge(segStr.getCoordinates(), new Label(oldLabel))\n      this.insertUniqueEdge(edge)\n    }\n  }\n  setNoder(noder) {\n    this._workingNoder = noder\n  }\n  setWorkingPrecisionModel(pm) {\n    this._workingPrecisionModel = pm\n  }\n  insertUniqueEdge(e) {\n    const existingEdge = this._edgeList.findEqualEdge(e)\n    if (existingEdge !== null) {\n      const existingLabel = existingEdge.getLabel()\n      let labelToMerge = e.getLabel()\n      if (!existingEdge.isPointwiseEqual(e)) {\n        labelToMerge = new Label(e.getLabel())\n        labelToMerge.flip()\n      }\n      existingLabel.merge(labelToMerge)\n      const mergeDelta = BufferBuilder.depthDelta(labelToMerge)\n      const existingDelta = existingEdge.getDepthDelta()\n      const newDelta = existingDelta + mergeDelta\n      existingEdge.setDepthDelta(newDelta)\n    } else {\n      this._edgeList.add(e)\n      e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()))\n    }\n  }\n  buildSubgraphs(subgraphList, polyBuilder) {\n    const processedGraphs = new ArrayList()\n    for (let i = subgraphList.iterator(); i.hasNext(); ) {\n      const subgraph = i.next()\n      const p = subgraph.getRightmostCoordinate()\n      const locater = new SubgraphDepthLocater(processedGraphs)\n      const outsideDepth = locater.getDepth(p)\n      subgraph.computeDepth(outsideDepth)\n      subgraph.findResultEdges()\n      processedGraphs.add(subgraph)\n      polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes())\n    }\n  }\n  createSubgraphs(graph) {\n    const subgraphList = new ArrayList()\n    for (let i = graph.getNodes().iterator(); i.hasNext(); ) {\n      const node = i.next()\n      if (!node.isVisited()) {\n        const subgraph = new BufferSubgraph()\n        subgraph.create(node)\n        subgraphList.add(subgraph)\n      }\n    }\n    Collections.sort(subgraphList, Collections.reverseOrder())\n    return subgraphList\n  }\n}\n","import BufferParameters from './BufferParameters.js'\nimport ScaledNoder from '../../noding/ScaledNoder.js'\nimport TopologyException from '../../geom/TopologyException.js'\nimport MathUtil from '../../math/MathUtil.js'\nimport PrecisionModel from '../../geom/PrecisionModel.js'\nimport RuntimeException from '../../../../../java/lang/RuntimeException.js'\nimport MCIndexSnapRounder from '../../noding/snapround/MCIndexSnapRounder.js'\nimport Geometry from '../../geom/Geometry.js'\nimport BufferBuilder from './BufferBuilder.js'\nexport default class BufferOp {\n  constructor() {\n    BufferOp.constructor_.apply(this, arguments)\n  }\n  static constructor_() {\n    this._argGeom = null\n    this._distance = null\n    this._bufParams = new BufferParameters()\n    this._resultGeometry = null\n    this._saveException = null\n    if (arguments.length === 1) {\n      const g = arguments[0]\n      this._argGeom = g\n    } else if (arguments.length === 2) {\n      const g = arguments[0], bufParams = arguments[1]\n      this._argGeom = g\n      this._bufParams = bufParams\n    }\n  }\n  static bufferOp() {\n    if (arguments.length === 2) {\n      const g = arguments[0], distance = arguments[1]\n      const gBuf = new BufferOp(g)\n      const geomBuf = gBuf.getResultGeometry(distance)\n      return geomBuf\n    } else if (arguments.length === 3) {\n      if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n        const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2]\n        const bufOp = new BufferOp(g)\n        bufOp.setQuadrantSegments(quadrantSegments)\n        const geomBuf = bufOp.getResultGeometry(distance)\n        return geomBuf\n      } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n        const g = arguments[0], distance = arguments[1], params = arguments[2]\n        const bufOp = new BufferOp(g, params)\n        const geomBuf = bufOp.getResultGeometry(distance)\n        return geomBuf\n      }\n    } else if (arguments.length === 4) {\n      const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2], endCapStyle = arguments[3]\n      const bufOp = new BufferOp(g)\n      bufOp.setQuadrantSegments(quadrantSegments)\n      bufOp.setEndCapStyle(endCapStyle)\n      const geomBuf = bufOp.getResultGeometry(distance)\n      return geomBuf\n    }\n  }\n  static precisionScaleFactor(g, distance, maxPrecisionDigits) {\n    const env = g.getEnvelopeInternal()\n    const envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()))\n    const expandByDistance = distance > 0.0 ? distance : 0.0\n    const bufEnvMax = envMax + 2 * expandByDistance\n    const bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0)\n    const minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits\n    const scaleFactor = Math.pow(10.0, minUnitLog10)\n    return scaleFactor\n  }\n  bufferFixedPrecision(fixedPM) {\n    const noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale())\n    const bufBuilder = new BufferBuilder(this._bufParams)\n    bufBuilder.setWorkingPrecisionModel(fixedPM)\n    bufBuilder.setNoder(noder)\n    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance)\n  }\n  bufferReducedPrecision() {\n    if (arguments.length === 0) {\n      for (let precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n        try {\n          this.bufferReducedPrecision(precDigits)\n        } catch (ex) {\n          if (ex instanceof TopologyException) \n            this._saveException = ex\n          else throw ex\n        } finally {}\n        if (this._resultGeometry !== null) return null\n      }\n      throw this._saveException\n    } else if (arguments.length === 1) {\n      const precisionDigits = arguments[0]\n      const sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits)\n      const fixedPM = new PrecisionModel(sizeBasedScaleFactor)\n      this.bufferFixedPrecision(fixedPM)\n    }\n  }\n  bufferOriginalPrecision() {\n    try {\n      const bufBuilder = new BufferBuilder(this._bufParams)\n      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance)\n    } catch (ex) {\n      if (ex instanceof RuntimeException) \n        this._saveException = ex\n      else throw ex\n    } finally {}\n  }\n  getResultGeometry(distance) {\n    this._distance = distance\n    this.computeGeometry()\n    return this._resultGeometry\n  }\n  setEndCapStyle(endCapStyle) {\n    this._bufParams.setEndCapStyle(endCapStyle)\n  }\n  computeGeometry() {\n    this.bufferOriginalPrecision()\n    if (this._resultGeometry !== null) return null\n    const argPM = this._argGeom.getFactory().getPrecisionModel()\n    if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM); else this.bufferReducedPrecision()\n  }\n  setQuadrantSegments(quadrantSegments) {\n    this._bufParams.setQuadrantSegments(quadrantSegments)\n  }\n}\nBufferOp.CAP_ROUND = BufferParameters.CAP_ROUND\nBufferOp.CAP_BUTT = BufferParameters.CAP_FLAT\nBufferOp.CAP_FLAT = BufferParameters.CAP_FLAT\nBufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE\nBufferOp.MAX_PRECISION_DIGITS = 12\n"],"names":["defaultcomparator","a","b","FastPriorityQueue","comparator","this","array","size","compare","prototype","clone","fpq","slice","add","myval","p","ap","i","heapify","arr","length","_percolateDown","_percolateUp","force","l","r","bestc","hsize","ai","_removeAt","index","poll","remove","removeOne","callback","removeMany","limit","Math","min","resultSize","result","Array","tmpSize","tmp","isEmpty","item","peek","ans","replaceTop","trim","forEach","kSmallest","k","newSize","smallest","module","exports","BufferParameters","constructor","constructor_","apply","arguments","_quadrantSegments","DEFAULT_QUADRANT_SEGMENTS","_endCapStyle","CAP_ROUND","_joinStyle","JOIN_ROUND","_mitreLimit","DEFAULT_MITRE_LIMIT","_isSingleSided","_simplifyFactor","DEFAULT_SIMPLIFY_FACTOR","quadrantSegments","setQuadrantSegments","endCapStyle","setEndCapStyle","joinStyle","mitreLimit","setJoinStyle","setMitreLimit","bufferDistanceError","quadSegs","alpha","PI","cos","getEndCapStyle","isSingleSided","JOIN_BEVEL","JOIN_MITRE","abs","getJoinStyle","setSimplifyFactor","simplifyFactor","getSimplifyFactor","getQuadrantSegments","getMitreLimit","setSingleSided","CAP_FLAT","CAP_SQUARE","SegmentPointComparator","relativeSign","x0","x1","compareValue","compareSign0","compareSign1","octant","p0","p1","equals2D","xSign","x","ySign","y","Assert","A","shouldNeverReachHere","SegmentNode","_segString","coord","segmentIndex","_segmentOctant","_isInterior","segString","segmentOctant","Coordinate","getCoordinate","print","out","compareTo","obj","other","isEndPoint","maxSegmentIndex","toString","isInterior","interfaces_","Comparable","SortedMap","Map","colorOf","color","parentOf","parent","setColor","c","leftOf","left","rightOf","right","TreeMap","super","root_","size_","get","key","cmp","value","put","getValue","getKey","t","oldValue","e","fixAfterInsertion","rotateLeft","rotateRight","values","arrayList","ArrayList","getFirstEntry","successor","entrySet","hashSet","HashSet","ch","containsKey","SegmentNodeList","_nodeMap","_edge","edge","getSplitCoordinates","coordList","CoordinateList","addEndpoints","it","iterator","eiPrev","next","hasNext","ei","addEdgeCoordinates","toCoordinateArray","println","findCollapsesFromExistingVertices","collapsedVertexIndexes","p2","Integer","valueOf","ei0","ei1","pts","createSplitEdgePts","findCollapseIndex","collapsedVertexIndex","numVerticesBetween","findCollapsesFromInsertedNodes","fill","getEdge","maxSegIndex","createSplitEdge","NodedSegmentString","getData","intPt","eiNew","getSegmentOctant","isTrue","checkSplitEdgesCorrectness","splitEdges","edgePts","getCoordinates","pt0","RuntimeException","splitnPts","ptn","addCollapsedNodes","vertexIndex","intValue","npts","lastSegStartPt","useIntPt1","ipt","addSplitEdges","edgeList","newEdge","GeometryLayout","GeometryType","POINT","LINE_STRING","LINEAR_RING","POLYGON","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","GEOMETRY_COLLECTION","CIRCLE","EMPTY","WKTGeometryType","type","toUpperCase","Lexer","wkt","index_","isAlpha_","isNumeric_","opt_decimal","undefined","isWhiteSpace_","nextChar_","charAt","nextToken","position","readNumber_","readText_","Error","decimal","scientificNotation","parseFloat","substring","Parser","lexer","factory","lexer_","token_","layout_","consume_","isTokenType","match","isMatch","parse","parseGeometry_","parseGeometryLayout_","layout","dimToken","dimInfo","parseGeometryCollectionText_","geometries","push","isEmptyGeometry_","formatErrorMessage_","parsePointText_","coordinates","parsePoint_","parseLineStringText_","parsePointList_","parsePolygonText_","parseLineStringTextList_","parseMultiPointText_","parsePointTextList_","parseMultiLineStringText_","parseMultiPolygonText_","parsePolygonTextList_","dimensions","token","o2c","ordinates","ca2p","rings","map","createLinearRing","createPolygon","geomType","createGeometryCollection","createPoint","components","createLineString","createMultiPoint","createMultiLineString","createMultiPolygon","polygons","encodePointGeometry","geom","cs","z","Number","isNaN","m","join","encodeLineStringGeometry","ii","encodePolygonGeometry","getExteriorRing","getNumInteriorRing","getInteriorRingN","GeometryEncoder","getNumGeometries","getGeometryN","encode","getGeometryType","geometryEncoder","encodeGeometryLayout","WKTParser","geometryFactory","GeometryFactory","precisionModel","getPrecisionModel","read","write","geometry","WKTWriter","parser","toLineString","Octant","dx","dy","IllegalArgumentException","adx","ady","SegmentString","isClosed","setData","data","NodableSegmentString","addIntersection","_nodeList","_pts","_data","getNodedSubstrings","segStrings","resultEdgelist","getNodeList","equals","safeOctant","CoordinateArraySequence","addIntersectionNode","normalizedSegmentIndex","nextSegIndex","nextPt","addIntersections","li","geomIndex","getIntersectionNum","intIndex","getIntersection","Noder","computeNodes","ScaledNoder","_noder","_scaleFactor","_offsetX","_offsetY","_isScaled","noder","scaleFactor","call","isIntegerPrecision","rescale","hasInterface","Collection","ss","System","scale","nodedSegmentStrings","roundPts","round","getZ","CoordinateArrays","removeRepeatedPoints","splitSS","inputSegStrings","intSegStrings","TopologyException","msg","pt","name","Object","keys","Intersection","intersection","q1","q2","minX0","minY0","maxX0","maxY0","minX1","minY1","maxX1","maxY1","midx","midy","p1x","p1y","p2x","p2y","q1x","q1y","q2x","q2y","px","py","pw","qx","qy","qw","w","xInt","yInt","Double","isInfinite","Distance","pointToSegmentString","line","minDistance","distance","dist","pointToSegment","segmentToSegment","B","C","D","noIntersection","Envelope","intersects","denom","r_num","s","MathUtil","pointToLinePerpendicular","len2","sqrt","LineIntersector","_result","_inputLines","_intPt","_intLineIndex","_isProper","_pa","_pb","_precisionModel","nonRobustComputeEdgeDistance","computeEdgeDistance","pdx","pdy","max","computeIntersection","p3","p4","computeIntersect","computeIntLineIndex","getEdgeDistance","isInteriorIntersection","inputLineIndex","isCollinear","COLLINEAR_INTERSECTION","getTopologySummary","getEndpoint","ptIndex","getIndexAlongSegment","catBuilder","StringBuilder","append","isProper","hasIntersection","setPrecisionModel","NO_INTERSECTION","isIntersection","getIntersectionAlongSegment","DONT_INTERSECT","DO_INTERSECT","COLLINEAR","POINT_INTERSECTION","RobustLineIntersector","nearestEndpoint","nearestPt","minDist","isInSegmentEnvelopes","env0","env1","contains","Orientation","intersectionSafe","makePrecise","checkDD","intPtDD","CGAlgorithmsDD","isIn","computeCollinearIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","Pq1","Pq2","Qp1","Qp2","NodingValidator","_li","_segStrings","checkEndPtVertexIntersections","testPt","j","checkInteriorIntersections","ss0","ss1","pts0","pts1","i0","i1","e0","segIndex0","e1","segIndex1","p00","p01","p10","p11","hasInteriorIntersection","checkValid","checkCollapses","checkCollapse","fact","Boundable","getBounds","ItemBoundable","_bounds","_item","bounds","getItem","Serializable","PriorityQueue","_fpQueue","clear","SpatialIndex","query","insert","itemEnv","AbstractNode","_childBoundables","_level","level","getLevel","addChildBoundable","childBoundable","computeBounds","getChildBoundables","Collections","reverseOrder","sort","toArray","Arrays","pos","alen","set","singletonList","o","EnvelopeDistance","y1","x2","y2","maximumDistance","env2","minx","getMinX","miny","getMinY","maxx","getMaxX","maxy","getMaxY","minMaxDistance","aminx","aminy","amaxx","amaxy","bminx","bminy","bmaxx","bmaxy","maxDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","BoundablePair","_boundable1","_boundable2","_distance","_itemDistance","boundable1","boundable2","itemDistance","area","getArea","isComposite","expandToQueue","priQ","isComp1","isComp2","expand","isLeaves","getBoundable","getDistance","nd","bndComposite","bndOther","isFlipped","child","bp","ItemVisitor","visitItem","AbstractSTRtree","_root","_built","_itemBoundables","_nodeCapacity","DEFAULT_NODE_CAPACITY","nodeCapacity","compareDoubles","queryInternal","searchBounds","visitor","childBoundables","getIntersectsOp","List","matches","boundablesAtLevel","boundables","top","boundable","getRoot","build","node","found","removeItem","childToPrune","createHigherLevels","boundablesOfALevel","parentBoundables","createParentBoundables","depth","maxChildDepth","childDepth","newLevel","createNode","sortedChildBoundables","getComparator","lastNode","getNodeCapacity","nodes","childToRemove","itemsTree","valuesTree","valuesTreeForNode","valuesTreeForChild","IntersectsOp","ItemDistance","item1","item2","STRtree","getItems","kNearestNeighbors","items","count","avg","centreY","centreX","isNull","intersectsOp","verticalSlices","sliceCount","sliceCapacity","trunc","ceil","slices","boundablesAddedToSlice","searchEnv","yComparator","createParentBoundablesFromVerticalSlice","minLeafCount","xComparator","createParentBoundablesFromVerticalSlices","nearestNeighbour","itemDist","initBndPair","distanceLowerBound","POSITIVE_INFINITY","minPair","bndPair","pairDistance","tree","bnd","nearestNeighbourK","isWithinDistance","distanceUpperBound","addAll","STRtreeNode","expandToInclude","Comparator","o1","o2","aBounds","bBounds","LineSegment","ls","y0","midPoint","minX","orientationIndex","seg","orient0","orient1","toGeometry","geomFactory","isVertical","minY","maxY","pointAlongOffset","segmentLengthFraction","offsetDistance","segx","segy","len","ux","uy","IllegalStateException","offsetx","offsety","setCoordinates","segmentFraction","inputPt","segFrac","projectionFactor","project","pf0","pf1","newp0","newp1","normalize","reverse","angle","atan2","distancePerpendicular","closestPoint","factor","NaN","closestPoints","closestPt","MAX_VALUE","close00","close01","close10","close11","maxX","getLength","comp0","temp","equalsTopo","lineIntersection","isHorizontal","reflect","getY","getX","A2plusB2","A2subB2","rx","ry","pointAlong","hashCode","bits0","doubleToLongBits","hash0","bits1","MonotoneChainOverlapAction","_overlapSeg1","_overlapSeg2","overlap","start1","mc2","start2","getLineSegment","MonotoneChain","_start","_end","_env","_context","_id","start","end","context","computeOverlaps","mc","mco","start0","end0","end1","overlaps","mid0","mid1","setId","id","select","mcs","computeSelect","getEnvelope","getEndIndex","getStartIndex","getContext","getId","mid","Quadrant","isNorthern","quad","NE","NW","isOpposite","quad1","quad2","commonHalfPlane","isInHalfPlane","halfPlane","SE","SW","quadrant","MonotoneChainBuilder","findChainEnd","safeStart","chainQuad","last","getChains","mcList","chainStart","chainEnd","SinglePassNoder","_segInt","segInt","setSegmentIntersector","MCIndexNoder","_monoChains","_index","_idCounter","_nodedSegStrings","_nOverlaps","si","getMonotoneChains","getIndex","segStr","intersectChains","overlapAction","SegmentOverlapAction","queryChain","testChain","isDone","_si","ss2","processIntersections","HotPixel","_pt","_originalPt","_ptScaled","_p0Scaled","_p1Scaled","_minx","_maxx","_miny","_maxy","_corner","_safeEnv","initCorners","intersectsScaled","segMinx","segMaxx","segMiny","segMaxy","isOutsidePixelEnv","intersectsToleranceSquare","copyScaled","pScaled","getSafeEnvelope","safeTolerance","SAFE_ENV_EXPANSION_FACTOR","intersectsPixelClosure","intersectsLeft","intersectsBottom","addSnappedNode","segIndex","tolerance","val","MonotoneChainSelectAction","selectedSegment","startIndex","MCIndexPointSnapper","snap","hotPixel","parentEdge","hotPixelVertexIndex","pixelEnv","hotPixelSnapAction","HotPixelSnapAction","isNodeAdded","_hotPixel","_parentEdge","_hotPixelVertexIndex","_isNodeAdded","isInteger","SegmentIntersector","InteriorIntersectionFinderAdder","_interiorIntersections","getInteriorIntersections","MCIndexSnapRounder","_pm","_pointSnapper","pm","getScale","checkCorrectness","inputSegmentStrings","resultSegStrings","nv","ex","Exception","printStackTrace","snapRound","intersections","findInteriorIntersections","computeIntersectionSnaps","computeVertexSnaps","intFinderAdder","edge0","snapPts","snapPt","Location","toLocationSymbol","locationValue","EXTERIOR","BOUNDARY","INTERIOR","NONE","Position","opposite","LEFT","RIGHT","ON","EmptyStackException","message","Stack","IndexOutOfBoundsException","pop","empty","search","indexOf","RightmostEdgeFinder","_minIndex","_minCoord","_minDe","_orientedDe","getRightmostSide","de","side","getRightmostSideOfSegment","checkForRightmostCoordinate","findRightmostEdgeAtVertex","pPrev","pNext","orientation","usePrev","COUNTERCLOCKWISE","CLOCKWISE","findRightmostEdgeAtNode","star","getNode","getEdges","getRightmostEdge","isForward","getSym","findEdge","dirEdgeList","LinkedList","addLast","removeFirst","shift","BufferSubgraph","_finder","_dirEdgeList","_nodes","_rightMostCoord","clearVisitedEdges","setVisited","graph","edgeEnv","addReachable","startNode","nodeStack","copySymDepths","sym","setDepth","getDepth","symNode","isVisited","getRightmostCoordinate","computeNodeDepth","n","startEdge","computeDepths","computeDepth","outsideDepth","getLabel","setEdgeDepths","create","findResultEdges","isInteriorAreaEdge","setInResult","nodesVisited","nodeQueue","adjNode","getNodes","getDirectedEdges","BufferInputLineSimplifier","_inputLine","_distanceTol","_isDeleted","_angleOrientation","inputLine","simplify","distanceTol","isDeletable","i2","isConcave","isShallow","isShallowSampled","deleteShallowConcavities","midIndex","findNextNonDeletedIndex","lastIndex","isChanged","isMiddleVertexDeleted","DELETE","isShallowConcavity","inc","NUM_PTS_TO_CHECK","collapseLine","INIT","KEEP","OffsetSegmentString","_ptList","_minimimVertexDistance","COORDINATE_ARRAY_TYPE","addPt","bufPt","isRedundant","addPts","lastPt","closeRing","startPt","setMinimumVertexDistance","minimimVertexDistance","Angle","toDegrees","radians","isAcute","dx0","dy0","isObtuse","interiorAngle","anglePrev","angleNext","normalizePositive","PI_TIMES_2","angleBetween","tip1","tail","tip2","a1","a2","diff","ang1","ang2","delAngle","toRadians","angleDegrees","getTurn","crossproduct","sin","angleBetweenOriented","angDel","PI_OVER_2","PI_OVER_4","OffsetSegmentGenerator","_maxCurveSegmentError","_filletAngleQuantum","_closingSegLengthFactor","_segList","_bufParams","_s0","_s1","_s2","_seg0","_seg1","_offset0","_offset1","_side","_hasNarrowConcaveAngle","bufParams","MAX_CLOSING_SEG_LEN_FACTOR","init","addMitreJoin","offset0","offset1","addLimitedMitreJoin","addLastSegment","initSideSegments","s1","s2","computeOffsetSegment","basePt","ang0","angDiffHalf","midAng","mitreMidAng","mitreDist","bevelHalfLen","bevelMidX","bevelMidY","bevelMidPt","mitreMidLine","bevelEndLeft","bevelEndRight","addDirectedFillet","startAngle","endAngle","direction","radius","directionFactor","totalAngle","nSegs","angleInc","offset","sideSign","addInsideTurn","addStartPoint","INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR","createCircle","addBevelJoin","CURVE_VERTEX_SNAP_DISTANCE_FACTOR","addCollinear","addCornerFillet","addNextSegment","outsideTurn","addOutsideTurn","addLineEndCap","offsetL","offsetR","squareCapSideOffset","squareCapLOffset","squareCapROffset","OFFSET_SEGMENT_SEPARATION_FACTOR","createSquare","addSegments","addFirstSegment","dx1","dy1","hasNarrowConcaveAngle","OffsetCurveBuilder","copyCoordinates","copy","getOffsetCurve","inputPts","isRightSide","posDistance","segGen","getSegGen","computePointCurve","computeOffsetCurve","curvePts","computeSingleSidedBufferCurve","distTol","simplifyTolerance","simp2","n2","simp1","n1","computeRingBufferCurve","simp","computeLineBufferCurve","getLineCurve","isLineOffsetEmpty","getBufferParameters","bufDistance","getRingCurve","TopologyLocation","location","on","gl","setAllLocations","locValue","setAllLocationsIfNull","isLine","merge","newLoc","getLocations","flip","posIndex","isEqualOnSide","le","locIndex","allPositionsEqual","loc","buf","StringBuffer","setLocations","isArea","isAnyNull","setLocation","Label","elt","onLoc","lbl","leftLoc","rightLoc","toLineLabel","label","lineLabel","getLocation","getGeometryCount","toLine","GraphComponent","_label","_isInResult","_isCovered","_isCoveredSet","_isVisited","isInResult","setLabel","setCovered","isCovered","updateIM","im","computeIM","isCoveredSet","Node","_coord","_edges","edges","isIncidentEdgeInResult","isIsolated","computeMergedLocation","label2","eltIndex","nLoc","argIndex","onLocation","mergeLabel","setNode","setLabelBoundary","NodeMap","nodeMap","nodeFact","getBoundaryNodes","bdyNodes","addNode","find","NodeFactory","EdgeEnd","_node","_p0","_p1","_dx","_dy","_quadrant","compareDirection","getDy","className","getClass","getName","lastDotPos","lastIndexOf","computeLabel","boundaryNodeRule","getDirectedCoordinate","getDx","getQuadrant","DirectedEdge","_isForward","_sym","_next","_nextMin","_edgeRing","_minEdgeRing","_depth","getNumPoints","computeDirectedLabel","depthFactor","currLocation","nextLocation","depthVal","setNextMin","nextMin","getDepthDelta","setMinEdgeRing","minEdgeRing","setSym","setVisitedEdge","getNextMin","getNext","isLineEdge","isExteriorIfArea0","isExteriorIfArea1","setEdgeRing","edgeRing","getMinEdgeRing","depthDelta","printEdge","printReverse","oppositePos","oppositeDepth","getEdgeRing","setNext","PlanarGraph","_edgeEndList","linkResultDirectedEdges","nodeit","printEdges","eiList","debugPrintln","isBoundaryNode","linkAllDirectedEdges","debugPrint","findEdgeEnd","getEdgeEnds","ee","eCoord","getNodeIterator","matchInSameDirection","ep0","ep1","getEdgeIterator","findEdgeInSameDirection","insertEdge","addEdges","edgesToAdd","de1","de2","RayCrossingCounter","_p","_crossingCount","_isPointOnSegment","locatePointInRing","CoordinateSequence","ring","counter","countSegment","isOnSegment","isPointInPolygon","orient","PointLocation","isInRing","locateInRing","isOnLine","lineIntersector","EdgeRing","_startDe","_maxNodeDegree","_ring","_isHole","_shell","_holes","_geometryFactory","computePoints","computeRing","isCCW","isFirstEdge","addPoints","getLinearRing","computeMaxNodeDegree","degree","getOutgoingDegree","containsPoint","shell","getEnvelopeInternal","getMaxNodeDegree","setShell","addHole","toPolygon","holeLR","isHole","isShell","getShell","deLabel","MinimalEdgeRing","er","MaximalEdgeRing","linkDirectedEdgesForMinimalEdgeRings","linkMinimalDirectedEdges","buildMinimalRings","minEdgeRings","minEr","PolygonBuilder","_shellList","findEdgeRingContaining","testEr","shellList","testRing","testEnv","getCoordinateN","minShell","minShellEnv","tryShell","tryShellRing","tryShellEnv","ptNotInList","isContained","sortShellsAndHoles","edgeRings","freeHoleList","computePolygons","resultPolyList","poly","placeFreeHoles","hole","buildMinimalEdgeRings","maxEdgeRings","findShell","placePolygonHoles","buildMaximalEdgeRings","dirEdges","getPolygons","shellCount","SubgraphDepthLocater","_subgraphs","_seg","subgraphs","findStabbedSegments","stabbingRayLeftPt","stabbedSegments","bsg","env","dirEdge","ds","DepthSegment","_leftDepth","_upwardSeg","compareX","seg0","seg1","compare0","orientIndex","NotRepresentableException","HCoordinate","_x","_y","_w","Triangle","circumcentre","cx","cy","ax","ay","bx","by","det","ccx","ccy","perpendicularBisector","l1","l2","angleBisector","len0","frac","inCentre","len1","circum","inCentreX","inCentreY","signedArea","m00","m01","m10","m11","interpolateZ","v0","v1","v2","d","u","longestSideLength","lenAB","lenBC","lenCA","maxLen","circumcentreDD","DD","subtract","determinant","multiply","asqr","sqr","bsqr","numx","numy","divide","doubleValue","area3D","uz","vx","vy","vz","crossx","crossy","crossz","absSq","centroid","OffsetCurveSetBuilder","_inputGeom","_curveBuilder","_curveList","inputGeom","curveBuilder","addRingSide","cwLeftLoc","cwRightLoc","LinearRing","MINIMUM_VALID_SIZE","curve","addCurve","addRingBothSides","addPoint","addPolygon","offsetSide","shellCoord","isErodedCompletely","holeCoord","isTriangleErodedCompletely","triangleCoord","bufferDistance","tri","addLineString","isRing","g","Polygon","LineString","Point","MultiPoint","addCollection","MultiLineString","MultiPolygon","GeometryCollection","getCurves","ringCoord","envMinDimension","getHeight","getWidth","gc","PointOnGeometryLocator","locate","GeometryCollectionIterator","_parent","_atStart","_max","_subcollectionIterator","isAtomic","NoSuchElementException","SimplePointInAreaLocator","_geom","locatePointInPolygon","shellLoc","holeLoc","locateInGeometry","containsPointInPolygon","geomi","g2","EdgeEndStar","_edgeMap","_edgeList","_ptInAreaLocation","getNextCW","iNextCW","propagateSideLabels","startLoc","currLoc","checkAreaLabelsConsistent","lastEdgeIndex","findIndex","eSearch","getGeometry","computeEdgeEndLabels","computeLabelling","geomGraph","getBoundaryNodeRule","hasDimensionalCollapseEdge","getDegree","insertEdgeEnd","isAreaLabelsConsistent","DirectedEdgeStar","_resultAreaEdgeList","_SCANNING_FOR_INCOMING","_LINKING_TO_OUTGOING","getResultAreaEdges","firstOut","incoming","state","nextOut","nextIn","de0","deLast","quad0","updateLabelling","nodeLabel","prevOut","firstIn","edgeIndex","startDepth","targetLastDepth","nextDepth","endIndex","currDepth","nextDe","mergeSymLabels","findCoveredLineEdges","eLabel","eLoc","OverlayNodeFactory","OrientedCoordinateArray","_orientation","increasingDirection","compareOriented","orientation1","pts2","orientation2","dir1","dir2","limit1","limit2","compPt","done1","done2","oca","EdgeList","_ocaMap","edgeColl","findEdgeIndex","findEqualEdge","IntersectionAdder","_hasIntersection","_hasProper","_hasProperInterior","_hasInterior","_properIntersectionPoint","_isSelfIntersection","numIntersections","numInteriorIntersections","numProperIntersections","numTests","isAdjacentSegments","isTrivialIntersection","getProperIntersectionPoint","hasProperInteriorIntersection","getLineIntersector","hasProperIntersection","EdgeIntersection","getSegmentIndex","EdgeIntersectionList","Edge","IntersectionMatrix","_matrix","setAll","Dimension","FALSE","elements","actualDimensionValue","TRUE","requiredDimensionSymbol","SYM_DONTCARE","SYM_TRUE","SYM_FALSE","SYM_P","P","SYM_L","L","SYM_A","requiredDimensionSymbols","isIntersects","isDisjoint","dimensionSymbols","row","col","toDimensionValue","column","dimensionValue","isContains","isWithin","isTouches","dimensionOfGeometryA","dimensionOfGeometryB","isOverlaps","isEquals","bi","setAtLeast","isCrosses","isCovers","isCoveredBy","minimumDimensionSymbols","minimumDimensionValue","setAtLeastIfValid","builder","setCharAt","toDimensionSymbol","transpose","Cloneable","Depth","NULL_VALUE","depthAtLocation","depthValue","minDepth","newValue","getDelta","IntArrayList","_size","initialCapacity","ensureCapacity","arraycopy","capacity","newLength","copyOf","MonotoneChainIndexer","toIntArray","list","OLDgetChainStartIndices","startIndexList","getChainStartIndices","MonotoneChainEdge","mcb","chainIndex","computeIntersectsForChain","chainIndex0","mce","chainIndex1","getStartIndexes","computeIntersects","_name","_mce","_isIsolated","_depthDelta","getCollapsedEdge","newPts","setIsolated","setName","isEqualForward","isEqualReverse","iRev","getMaximumSegmentIndex","setDepthDelta","getEdgeIntersectionList","isCollapsed","getMonotoneChainEdge","isPointwiseEqual","BufferBuilder","_workingPrecisionModel","_workingNoder","_geomFact","_graph","convertSegStrings","lines","buildGeometry","lLoc","rLoc","createEmptyResultGeometry","getNoder","buffer","getFactory","bufferSegStrList","computeNodedEdges","subgraphList","createSubgraphs","polyBuilder","buildSubgraphs","oldLabel","insertUniqueEdge","setNoder","setWorkingPrecisionModel","existingEdge","existingLabel","labelToMerge","mergeDelta","newDelta","processedGraphs","subgraph","BufferOp","_argGeom","_resultGeometry","_saveException","bufferOp","getResultGeometry","Geometry","bufOp","precisionScaleFactor","maxPrecisionDigits","bufEnvMax","minUnitLog10","log","pow","bufferFixedPrecision","fixedPM","PrecisionModel","bufBuilder","bufferReducedPrecision","precDigits","MAX_PRECISION_DIGITS","precisionDigits","sizeBasedScaleFactor","bufferOriginalPrecision","computeGeometry","argPM","getType","FIXED","CAP_BUTT"],"sourceRoot":""}